// Generated by CoffeeScript 1.3.3
(function() {
  var S;

  S = {
    Collections: {},
    Views: {},
    Models: {}
  };

  window.S = S;

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var HeightMap, exports;

  HeightMap = (function() {

    function HeightMap(size, low_value, high_value) {
      this.size = size;
      this.low_value = low_value != null ? low_value : 0;
      this.high_value = high_value != null ? high_value : 255;
      this.mid_value = Math.floor((this.low_value + this.high_value) / 2);
      this.centre_cell = Math.floor(this.size / 2);
      this.reset();
    }

    HeightMap.prototype.reset = function() {
      var x, y,
        _this = this;
      while (this.remaining()) {
        this.pop();
      }
      this.map = (function() {
        var _i, _ref, _results;
        _results = [];
        for (x = _i = 1, _ref = this.size; 1 <= _ref ? _i <= _ref : _i >= _ref; x = 1 <= _ref ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref1, _results1;
            _results1 = [];
            for (y = _j = 1, _ref1 = this.size; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 1 <= _ref1 ? ++_j : --_j) {
              _results1.push(null);
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }).call(this);
      this.set_nw(this.mid_value);
      this.set_ne(this.mid_value);
      this.set_sw(this.mid_value);
      this.set_se(this.mid_value);
      return this.push(function() {
        return _this.diamond_square(0, 0, _this.size - 1, _this.size - 1, _this.mid_value);
      });
    };

    HeightMap.prototype.get_cell = function(x, y) {
      return this.map[y][x];
    };

    HeightMap.prototype.set_cell = function(x, y, v) {
      return this.map[y][x] = v;
    };

    HeightMap.prototype.soft_set_cell = function(x, y, v) {
      var _base;
      return (_base = this.map[y])[x] || (_base[x] = v);
    };

    HeightMap.prototype.set_nw = function(v) {
      return this.set_cell(0, 0, v);
    };

    HeightMap.prototype.set_ne = function(v) {
      return this.set_cell(0, this.size - 1, v);
    };

    HeightMap.prototype.set_sw = function(v) {
      return this.set_cell(this.size - 1, 0, v);
    };

    HeightMap.prototype.set_se = function(v) {
      return this.set_cell(this.size - 1, this.size - 1, v);
    };

    HeightMap.prototype.set_centre = function(v) {
      return this.set_cell(this.centre_cell, this.centre_cell, v);
    };

    HeightMap.prototype.push = function(value) {
      if (this.queue) {
        this.queue.push(value);
      } else {
        this.queue = [value];
      }
      return this.queue;
    };

    HeightMap.prototype.pop = function() {
      if (this.queue != null) {
        return this.queue.shift();
      }
    };

    HeightMap.prototype.remaining = function() {
      if ((this.queue != null) && this.queue.length > 0) {
        return true;
      } else {
        return false;
      }
    };

    HeightMap.prototype.step = function() {
      return this.pop()();
    };

    HeightMap.prototype.run = function() {
      while (this.remaining()) {
        this.step();
      }
      return null;
    };

    HeightMap.prototype.diamond_square = function(left, top, right, bottom, base_height) {
      var centre_point_value, x_centre, y_centre,
        _this = this;
      x_centre = Math.floor((left + right) / 2);
      y_centre = Math.floor((top + bottom) / 2);
      centre_point_value = Math.floor(((this.get_cell(left, top) + this.get_cell(right, top) + this.get_cell(left, bottom) + this.get_cell(right, bottom)) / 4) - (Math.floor((Math.random() - 0.5) * base_height * 2)));
      this.soft_set_cell(x_centre, y_centre, centre_point_value);
      this.soft_set_cell(x_centre, top, Math.floor((this.get_cell(left, top) + this.get_cell(right, top)) / 2 + ((Math.random() - 0.5) * base_height)));
      this.soft_set_cell(x_centre, bottom, Math.floor((this.get_cell(left, bottom) + this.get_cell(right, bottom)) / 2 + ((Math.random() - 0.5) * base_height)));
      this.soft_set_cell(left, y_centre, Math.floor((this.get_cell(left, top) + this.get_cell(left, bottom)) / 2 + ((Math.random() - 0.5) * base_height)));
      this.soft_set_cell(right, y_centre, Math.floor((this.get_cell(right, top) + this.get_cell(right, bottom)) / 2 + ((Math.random() - 0.5) * base_height)));
      if ((right - left) > 2) {
        base_height = Math.floor(base_height * Math.pow(2.0, -0.75));
        this.push(function() {
          return _this.diamond_square(left, top, x_centre, y_centre, base_height);
        });
        this.push(function() {
          return _this.diamond_square(x_centre, top, right, y_centre, base_height);
        });
        this.push(function() {
          return _this.diamond_square(left, y_centre, x_centre, bottom, base_height);
        });
        return this.push(function() {
          return _this.diamond_square(x_centre, y_centre, right, bottom, base_height);
        });
      }
    };

    HeightMap.prototype.tile = function(x, y) {
      return {
        nw: this.get_cell(x, y),
        ne: this.get_cell(x + 1, y),
        sw: this.get_cell(x, y + 1),
        se: this.get_cell(x + 1, y + 1)
      };
    };

    return HeightMap;

  })();

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    exports = module.exports = HeightMap;
  } else {
    window.S.HeightMap = HeightMap;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var Backbone, GameObject, exports, _;

  if (typeof require !== "undefined" && require !== null) {
    _ = require('underscore');
    Backbone = require('backbone');
  } else {
    _ = window._;
    Backbone = window.Backbone;
  }

  GameObject = (function() {

    GameObject.prototype.behaviour = {};

    GameObject.prototype.state = {};

    function GameObject(behaviour, state) {
      this.behaviour = behaviour;
      this.state = state;
      _.extend(this, Backbone.Events);
      this.on('accept', this.accept, this);
      this.on('produce', this.produce, this);
      this.on('route', this.route, this);
    }

    GameObject.prototype.type = function() {
      return this.state.type;
    };

    GameObject.prototype.requestAccept = function(signal) {
      return this.behaviour.requestAccept(signal, this.state);
    };

    GameObject.prototype.actionMenu = function() {
      return this.behaviour.actionMenu(this.state);
    };

    GameObject.prototype.accept = function(signal, callback) {
      return this.behaviour.accept(signal, this.state, callback, this);
    };

    GameObject.prototype.produce = function() {
      return this.behaviour.produce(this.state);
    };

    GameObject.prototype.route = function() {
      return this.behaviour.route(this.state, this);
    };

    return GameObject;

  })();

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    exports = module.exports = GameObject;
  } else {
    window.S.GameObject = GameObject;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var ObjectState, exports;

  ObjectState = (function() {

    function ObjectState() {
      var i, _i;
      this.type = 0;
      this.fov = 1;
      this.owner = {};
      this.id = 0;
      this.name = 'Object';
      this.field = {};
      this.signals = [];
      this.routing = {};
      for (i = _i = 0; _i <= 5; i = ++_i) {
        this.routing[i] = {
          "in": false,
          out: false,
          object: null
        };
      }
      this.delay = 1000;
      this.extraction = 20;
      this.capacity = 10;
      this.life = 100;
      this.routeCounter = 0;
    }

    return ObjectState;

  })();

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    exports = module.exports = ObjectState;
  } else {
    window.S.ObjectState = ObjectState;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var Field, exports;

  Field = (function() {

    function Field(x, y) {
      this.xy = [x, y];
      this.channels = {};
      this.platform = {};
      this.resource = {};
      this.terrain = [];
      this.owner = {};
    }

    return Field;

  })();

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    exports = module.exports = Field;
  } else {
    window.S.Field = Field;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var Signal, exports;

  Signal = (function() {
    /*
        # Strength of the signal
        # Has different meanings when reaching different fields
        # When signal reaches storage or HQ strength translates into amount of
        # resouces player receives of given type
        # If the signal reaches enemy structure strength is the parameter which
        # determines the amount of damage dealt to the structure
    */

    Signal.prototype.strength = 0;

    Signal.prototype.source = {};

    Signal.prototype.type = 0;

    Signal.prototype.owner = {};

    function Signal(events, strength, type, source) {
      this.events = events;
      this.strength = strength;
      this.type = type;
      this.source = source;
      this.owner = this.source.owner;
    }

    return Signal;

  })();

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    exports = module.exports = Signal;
  } else {
    window.S.Signal = Signal;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var Types, exports;

  Types = {
    UI: {
      Size: 45,
      Margin: 150
    },
    Entities: {
      Channel: 1,
      Signal: 2,
      Player: 3,
      Platforms: {
        HQ: 4,
        Normal: 5
      },
      Names: ['', 'Channel', 'Signal', 'Player', 'HQ', 'Platform']
    },
    Terrain: {
      Water: 1,
      Sand: 2,
      Dirt: 3,
      Rocks: 4,
      Deepwater: 5,
      Grass: 6,
      Snow: 7,
      Names: ["Water", "Sand", "Dirt", "Rocks", "Deepwater", "Grass", "Snow"]
    },
    Resources: {
      Gold: 6,
      Food: 7,
      Names: ["Gold", "Food"],
      Amounts: [1000, 1000],
      Lifes: [
        function() {
          return Math.round((Math.random() * 2000 % 760) + 500);
        }, function() {
          return Math.round((Math.random() * 4000 % 1260) + 300);
        }
      ]
    },
    Events: {
      Routing: {
        title: 'set routing'
      },
      Build: {
        title: 'build',
        Channel: {
          title: 'channel',
          cost: {
            Gold: 100,
            Food: 40
          }
        },
        Platform: {
          title: 'platform',
          cost: {
            Gold: 400,
            Food: 200
          }
        }
      }
    },
    Games: {
      FFA: {
        Number2: 0,
        Number3: 1,
        Number4: 2,
        Number5: 3,
        Number6: 4
      },
      Info: {
        0: {
          name: 'Deathmatch',
          numberOfSides: 2,
          playersOnASide: 1,
          minWidth: 8,
          maxWidth: 15,
          startingPoints: [[2, 2], [7, 12]],
          teams: false
        },
        1: {
          name: 'Deathmatch',
          numberOfSides: 3,
          playersOnASide: 1,
          teams: false
        },
        2: {
          name: 'Deathmatch',
          numberOfSides: 4,
          playersOnASide: 1,
          teams: false
        }
      }
    }
  };

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    exports = module.exports = Types;
  } else {
    window.S.Types = Types;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var Player, S, exports, _;

  S = {};

  if (typeof require !== "undefined" && require !== null) {
    _ = require('underscore');
    S.Types = require('../config/Types');
  } else {
    S.Types = window.S.Types;
  }

  Player = (function() {

    function Player() {
      this.resources = {};
    }

    Player.prototype.addResource = function(s) {
      var _base, _name, _ref;
      if ((_ref = (_base = this.resources)[_name = S.Types.Resources.Names[s.type - 6]]) == null) {
        _base[_name] = 0;
      }
      return this.resources[S.Types.Resources.Names[s.type - 6]] += s.strength;
    };

    Player.prototype.spendResources = function(t, x) {
      if (this.resources[t] >= x) {
        this.resources[t] -= x;
        return true;
      } else {
        return false;
      }
    };

    return Player;

  })();

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    exports = module.exports = Player;
  } else {
    window.S.Player = Player;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var Properties, S, deepClone, defaultRoute, exports, field, i, _, _i, _j, _k, _len, _ref, _ref1;

  S = {};

  if (typeof require !== "undefined" && require !== null) {
    S.Types = require('./Types');
    _ = require('underscore')._;
  } else {
    S.Types = window.S.Types;
    _ = window._;
  }

  Properties = {
    platform: {
      type: S.Types.Entities.Platforms.Normal,
      id: 0,
      fov: 1,
      name: 'Object',
      field: {},
      signals: [],
      routing: {},
      delay: 200,
      extraction: 20,
      capacity: 10,
      life: 100
    },
    channel: {
      type: S.Types.Entities.Channel,
      id: 0,
      fov: 1,
      name: 'Channel',
      field: {},
      signals: [],
      routing: {},
      delay: 1000,
      extraction: 20,
      capacity: 10,
      life: 100,
      someField: "value"
    },
    HQ: {
      type: S.Types.Entities.Platforms.HQ,
      id: 0,
      fov: 1,
      name: 'HQ',
      field: {},
      signals: [],
      routing: {},
      delay: 4000,
      extraction: 20,
      capacity: 10,
      life: 100
    },
    signal: {
      type: S.Types.Entities.Signal,
      id: 0,
      name: 'Signal',
      strength: 0,
      source: {},
      resource: ""
    },
    resource: {
      type: S.Types.Resources.Food,
      id: 0,
      fov: 0,
      name: 'Resource',
      field: {},
      signals: [],
      routing: {},
      delay: 4000,
      extraction: 20,
      capacity: 10,
      life: 100
    },
    player: {
      resources: {}
    }
  };

  for (i = _i = 0, _ref = S.Types.Resources.Names.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    Properties.player.resources[S.Types.Resources.Names[i]] = S.Types.Resources.Amounts[i];
  }

  defaultRoute = {
    object: {},
    "in": true,
    out: true
  };

  deepClone = function(obj, deep) {
    var func, isArr;
    if (!_.isObject(obj) || _.isFunction(obj)) {
      return obj;
    }
    if (_.isDate(obj)) {
      return new Date(obj.getTime());
    }
    if (_.isRegExp(obj)) {
      return new RegExp(obj.source, obj.toString().replace(/.*\//, ""));
    }
    isArr = _.isArray(obj) || _.isArguments(obj);
    if (deep) {
      func = function(memo, value, key) {
        if (isArr) {
          memo.push(deepClone(value, true));
        } else {
          memo[key] = deepClone(value, true);
        }
        return memo;
      };
      return _.reduce(obj, func, (isArr ? [] : {}));
    } else {
      if (isArr) {
        return slice.call(obj);
      } else {
        return _.extend({}, obj);
      }
    }
  };

  _ref1 = ['channel', 'HQ', 'platform'];
  for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
    field = _ref1[_j];
    for (i = _k = 0; _k <= 5; i = ++_k) {
      Properties[field].routing[i] = deepClone(defaultRoute, true);
    }
  }

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    exports = module.exports = Properties;
  } else {
    window.S.Properties = Properties;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var S, SignalFactory, exports, _,
    __slice = [].slice;

  S = {};

  if (typeof require !== "undefined" && require !== null) {
    _ = require('underscore')._;
    S.Types = require('./Types');
    S.Signal = require('../objects/Signal');
  } else {
    _ = window._;
    S.Signal = window.S.Signal;
    S.Types = window.S.Types;
  }

  SignalFactory = (function() {

    function SignalFactory() {
      var _this = this;
      this.builders = {};
      this.builders[S.Types.Entities.Signal] = function(id, args) {
        var events, name, signal, source, st, strength, type;
        events = args[0];
        strength = args[1];
        type = args[2];
        source = args[3];
        name = 'Signal' + id;
        st = new S.Signal(events, strength, type, source);
        return signal = _.extend(st, {
          'name': name,
          'id': id
        });
      };
    }

    SignalFactory.prototype.build = function() {
      var args, kind, uid;
      kind = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!kind) {
        console.error("kind is undefined");
      }
      if (!_.isFunction(this.builders[kind])) {
        throw Error(kind + " is not a valid Entity type");
      }
      uid = _.uniqueId();
      return this.builders[kind](uid, args);
    };

    return SignalFactory;

  })();

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    exports = module.exports = new SignalFactory();
  } else {
    window.S.SignalFactory = new SignalFactory();
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var HQBehaviour, S, exports;

  S = {};

  if (typeof require !== "undefined" && require !== null) {
    S.SignalFactory = require('../config/SignalFactory');
    S.Types = require('../config/Types');
  } else {
    S.Types = window.S.Types;
    S.SignalFactory = window.S.SignalFactory;
  }

  HQBehaviour = (function() {

    function HQBehaviour(eventBus) {
      this.eventBus = eventBus;
      this.resourceCounter = 0;
    }

    HQBehaviour.prototype.actionMenu = function(state) {
      var menu, possibleChannels, possibleRoutes, x, y, _ref;
      possibleRoutes = [];
      _.each(state.routing, function(route, direction) {
        if (!_.isEmpty(route.object)) {
          return possibleRoutes.push(+direction);
        }
      });
      _ref = state.field.xy, x = _ref[0], y = _ref[1];
      possibleChannels = this.eventBus.getPossibleChannels(x, y);
      return menu = [['build:channel', 'routing', '/:HQ', '/!platforminfo'], [possibleChannels, possibleRoutes]];
    };

    HQBehaviour.prototype.requestAccept = function(signal, state) {
      return true;
    };

    HQBehaviour.prototype.produce = function(state) {
      var production,
        _this = this;
      if (state.field.resource.type != null) {
        state.field.resource.trigger('produce');
      }
      production = function() {
        var type;
        if (!state.field.platform.state.owner) {
          console.log(["Missing owner - HQ"], state.field);
        }
        type = S.Types.Resources.Gold + (_this.resourceCounter % S.Types.Resources.Names.length);
        state.owner.addResource(S.SignalFactory.build(S.Types.Entities.Signal, _this.eventBus, state.extraction, type, state.field.platform));
        _this.eventBus.trigger('resource:receive', state.field.xy, state.extraction, type);
        return _this.resourceCounter++;
      };
      return setInterval(production, state.delay);
    };

    HQBehaviour.prototype.accept = function(signal, state, callback, ownObject) {
      callback(signal);
      if (signal.owner.id === state.owner.id) {
        console.log("[HQBehaviour]: I accept a signal");
        state.owner.addResource(signal);
        return this.eventBus.trigger('resource:receive', state.field.xy, signal.strength, signal.type);
      } else {
        state.life -= signal.strength;
        if (state.life <= 0) {
          return this.eventBus.trigger('player:lost', state.owner);
        }
      }
    };

    HQBehaviour.prototype.route = function(state, ownObject) {};

    return HQBehaviour;

  })();

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    exports = module.exports = HQBehaviour;
  } else {
    window.S.HQBehaviour = HQBehaviour;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var ChannelBehaviour, S, exports, _;

  S = {};

  if (typeof require !== "undefined" && require !== null) {
    S.Types = require('../config/Types');
    S.Properties = require('../config/Properties');
    _ = require('underscore');
  } else {
    S.Properties = window.S.Properties;
    S.Types = window.S.Types;
    _ = window._;
  }

  ChannelBehaviour = (function() {

    function ChannelBehaviour(eventBus) {
      this.eventBus = eventBus;
    }

    ChannelBehaviour.prototype.actionMenu = function(state) {
      var menu, possibleRoutes;
      possibleRoutes = [];
      _.each(state.routing, function(route, direction) {
        if (!_.isEmpty(route.object)) {
          return possibleRoutes.push(+direction);
        }
      });
      return menu = [['routing'], [possibleRoutes]];
    };

    ChannelBehaviour.prototype.requestAccept = function(signal, state) {
      var availableRoutes;
      if (state.capacity <= state.signals.length) {
        this.eventBus.trigger('full:channel', state.fields);
      }
      if (signal.owner.id === state.owner.id) {
        availableRoutes = _.filter(state.routing, function(route) {
          var _ref, _ref1;
          return route["in"] && ((_ref = route.object) != null ? (_ref1 = _ref.state) != null ? _ref1.id : void 0 : void 0) === signal.source.id;
        });
        return availableRoutes.length > 0 && state.capacity > state.signals.length;
      } else {
        return true;
      }
    };

    ChannelBehaviour.prototype.produce = function(state) {
      return null;
    };

    ChannelBehaviour.prototype.accept = function(signal, state, callback, ownObject) {
      var addSignal,
        _this = this;
      callback(signal);
      if (state.owner.id === signal.owner.id) {
        addSignal = function(signal) {
          ownObject.state.signals.push(signal);
          return ownObject.trigger('route');
        };
        return _.delay(addSignal, state.delay, signal);
      } else {
        state.life -= signal.strength;
        console.log("[ChannelBehaviour]: signal dealt damage, life is:", state.life);
        if (state.life <= 0) {
          state.owner = signal.owner;
          state.life = S.Properties.channel.life;
          if (signal.source.type === S.Types.Entities.Channel) {
            console.log("owning channel");
            return this.eventBus.trigger('owner:channel', state.fields, signal.source.fields, signal.owner.id);
          } else {
            return this.eventBus.trigger('owner:channel', state.fields, [signal.source.field], signal.owner.id);
          }
        }
      }
    };

    ChannelBehaviour.prototype.route = function(state, ownObject) {
      var availableRoutes, dest, destination, field, field2, origOwner, origSource, signal;
      signal = ownObject.state.signals.shift();
      if (signal != null) {
        availableRoutes = [];
        _.each(state.routing, function(route, direction) {
          var _ref, _ref1;
          if ((route.object.type != null) && ((_ref = route.object) != null ? (_ref1 = _ref.state) != null ? _ref1.name : void 0 : void 0) !== signal.source.name) {
            return availableRoutes.push([route, direction]);
          }
        });
        if (availableRoutes.length > 0) {
          destination = availableRoutes[0];
          origSource = signal.source;
          origOwner = signal.owner;
          signal.source = state;
          signal.owner = state.owner;
          if (destination[0].object.requestAccept(signal)) {
            if (destination[0].object.type() === S.Types.Entities.Channel) {
              field = _.intersection(state.fields, destination[0].object.state.fields);
              field2 = _.difference(destination[0].object.state.fields, state.fields);
              dest = this.eventBus.directionGet(state.owner, field[0].xy[0], field[0].xy[1], field2[0].xy[0], field2[0].xy[1]);
              this.eventBus.trigger('move:signal', field[0].xy, dest);
            }
            return destination[0].object.trigger('accept', signal, function(signal) {
              if (ownObject.state.signals.length > 0) {
                return ownObject.trigger('route');
              }
            });
          } else {
            signal.source = origSource;
            signal.owner = origOwner;
            return ownObject.state.signals.push(signal);
          }
        } else {
          return ownObject.state.signals.push(signal);
        }
      }
    };

    return ChannelBehaviour;

  })();

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    exports = module.exports = ChannelBehaviour;
  } else {
    window.S.ChannelBehaviour = ChannelBehaviour;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var PlatformBehaviour, S, exports, _;

  S = {};

  if (typeof require !== "undefined" && require !== null) {
    _ = require('underscore');
    S.Types = require('../config/Types');
    S.Properties = require('../config/Properties');
  } else {
    _ = window._;
    S.Types = window.S.Types;
    S.Properties = window.S.Properties;
  }

  PlatformBehaviour = (function() {

    function PlatformBehaviour(eventBus) {
      this.eventBus = eventBus;
    }

    PlatformBehaviour.prototype.actionMenu = function(state) {
      var menu, possibleChannels, possibleRoutes, x, y, _ref;
      possibleRoutes = [];
      _.each(state.routing, function(route, direction) {
        if (!_.isEmpty(route.object)) {
          return possibleRoutes.push(+direction);
        }
      });
      _ref = state.field.xy, x = _ref[0], y = _ref[1];
      possibleChannels = this.eventBus.getPossibleChannels(x, y);
      return menu = [['build:channel', 'routing', '/:Platform', '/!platforminfo'], [possibleChannels, possibleRoutes]];
    };

    PlatformBehaviour.prototype.requestAccept = function(signal, state) {
      var availableRoutes;
      if (signal.owner.id === state.owner.id) {
        availableRoutes = _.filter(state.routing, function(route) {
          var _ref, _ref1;
          return route["in"] && ((_ref = route.object) != null ? (_ref1 = _ref.state) != null ? _ref1.id : void 0 : void 0) === signal.source.id;
        });
        return availableRoutes.length > 0 && state.capacity >= state.signals.length;
      } else if (signal.owner.id === this.eventBus.nonUserId(state.owner)) {
        return state.capacity > state.signals.length;
      } else {
        return true;
      }
    };

    PlatformBehaviour.prototype.produce = function(state) {
      if (state.field.resource.type != null) {
        return state.field.resource.trigger('produce');
      }
    };

    PlatformBehaviour.prototype.accept = function(signal, state, callback, ownObject) {
      var addSignal, _ref,
        _this = this;
      callback(signal);
      if (((_ref = signal.owner) != null ? _ref.id : void 0) === state.owner.id || signal.owner.id === this.eventBus.nonUserId(state.owner)) {
        addSignal = function(signal) {
          ownObject.state.signals.push(signal);
          return ownObject.trigger('route');
        };
        return _.delay(addSignal, state.delay, signal);
      } else {
        state.life -= signal.strength;
        console.log("[PlatformBehaviour]: signal dealt damage, life is:", state.life);
        if (state.life <= 0) {
          state.owner = signal.owner;
          state.life = S.Properties.platform.life;
          return this.eventBus.trigger('owner:platform', state.field.xy, signal.owner.id);
        }
      }
    };

    PlatformBehaviour.prototype.depleted = function(state) {};

    PlatformBehaviour.prototype.route = function(state, ownObject) {
      var availableRoutes, destNum, destination, origOwner, origSource, signal;
      signal = ownObject.state.signals.shift();
      if (signal != null) {
        availableRoutes = [];
        _.each(state.routing, function(route, direction) {
          var _ref;
          if (route.out && (((_ref = route.object) != null ? _ref.type : void 0) != null)) {
            return availableRoutes.push([route, direction]);
          }
        });
        if (availableRoutes.length > 0) {
          destNum = state.routeCounter % availableRoutes.length;
          state.routeCounter++;
          destination = availableRoutes[destNum];
          origOwner = signal.owner;
          origSource = signal.source;
          signal.source = state;
          signal.owner = state.owner;
          if (destination[0].object.requestAccept(signal)) {
            this.eventBus.trigger('move:signal', state.field.xy, destination[1]);
            return destination[0].object.trigger('accept', signal, function(signal) {
              if (ownObject.state.signals.length > 0) {
                return ownObject.trigger('route');
              }
            });
          } else {
            signal.source = origSource;
            signal.owner = origOwner;
            return ownObject.state.signals.push(signal);
          }
        } else {
          return ownObject.state.signals.push(signal);
        }
      }
    };

    return PlatformBehaviour;

  })();

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    exports = module.exports = PlatformBehaviour;
  } else {
    window.S.PlatformBehaviour = PlatformBehaviour;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var ResourceBehaviour, S, exports, _;

  S = {};

  if (typeof require !== "undefined" && require !== null) {
    _ = require('underscore');
    S.SignalFactory = require('../config/SignalFactory');
    S.Types = require('../config/Types');
  } else {
    _ = window._;
    S.SignalFactory = window.S.SignalFactory;
    S.Types = window.S.Types;
  }

  ResourceBehaviour = (function() {

    function ResourceBehaviour(resourceType, eventBus) {
      this.resourceType = resourceType;
      this.eventBus = eventBus;
    }

    ResourceBehaviour.prototype.actionMenu = function(state) {
      return [];
    };

    ResourceBehaviour.prototype.requestAccept = function(signal, state) {};

    ResourceBehaviour.prototype.accept = function(signal, state, callback, ownObject) {};

    ResourceBehaviour.prototype.route = function(state, ownObject) {};

    ResourceBehaviour.prototype.produce = function(state) {
      var production,
        _this = this;
      production = function() {
        var acceptable, extractAmount, newSignal;
        if (state.life <= 0) {
          if (_this.PID != null) {
            return clearInterval(_this.PID);
          }
        } else {
          if (!state.field.platform.state.owner) {
            console.log(["Missing owner - Res"], state.field);
          }
          extractAmount = state.life >= state.extraction ? state.extraction : state.life;
          newSignal = S.SignalFactory.build(S.Types.Entities.Signal, _this.eventBus, extractAmount, _this.resourceType, state);
          _this.eventBus.trigger('resource:produce', state.field.xy, state.extraction, _this.resourceType);
          acceptable = state.field.platform.requestAccept(newSignal);
          if (acceptable) {
            state.life -= extractAmount;
            return state.field.platform.trigger("accept", newSignal, function(signal) {});
          }
        }
      };
      return this.PID = setInterval((function() {
        return production();
      }), state.delay);
    };

    return ResourceBehaviour;

  })();

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    exports = module.exports = ResourceBehaviour;
  } else {
    window.S.ResourceBehaviour = ResourceBehaviour;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3

/*
load dependencies for server and client
coffee declraes all varialbes in
*/


(function() {
  var ObjectFactory, S, exports, _,
    __slice = [].slice;

  S = {};

  if (typeof require !== "undefined" && require !== null) {
    _ = require('underscore')._;
    S.Properties = require('./Properties');
    S.Types = require('./Types');
    S.Player = require('../models/Player');
    S.GameObject = require('../objects/GameObject');
    S.SignalFactory = require('./SignalFactory');
    S.ObjectState = require('../objects/ObjectState');
    S.HQBehaviour = require('../behaviours/HQBehaviour');
    S.ChannelBehaviour = require('../behaviours/ChannelBehaviour');
    S.PlatformBehaviour = require('../behaviours/PlatformBehaviour');
    S.ResourceBehaviour = require('../behaviours/ResourceBehaviour');
  } else {
    _ = window._;
    S.Properties = window.S.Properties;
    S.Types = window.S.Types;
    S.Player = window.S.Player;
    S.GameObject = window.S.GameObject;
    S.SignalFactory = window.S.SignalFactory;
    S.ObjectState = window.S.ObjectState;
    S.HQBehaviour = window.S.HQBehaviour;
    S.ChannelBehaviour = window.S.ChannelBehaviour;
    S.PlatformBehaviour = window.S.PlatformBehaviour;
    S.ResourceBehaviour = window.S.ResourceBehaviour;
  }

  ObjectFactory = (function() {

    function ObjectFactory() {
      var _this = this;
      this.builders = {};
      this.builders[S.Types.Entities.Platforms.Normal] = function(id, args) {
        var events, name, object, owner, st, state;
        events = args[0];
        owner = args[1];
        name = 'Platform' + id;
        st = new S.ObjectState();
        state = _.extend(st, _this.deepClone(S.Properties.platform, true));
        state = _.extend(state, {
          'name': name,
          'id': id,
          'owner': owner,
          'type': S.Types.Entities.Platforms.Normal
        });
        return object = new S.GameObject(new S.PlatformBehaviour(events), state);
      };
      this.builders[S.Types.Entities.Platforms.HQ] = function(id, args) {
        var events, name, object, owner, st, state;
        events = args[0];
        owner = args[1];
        name = 'HQ' + id;
        st = new S.ObjectState();
        state = _.extend(st, _this.deepClone(S.Properties.HQ, true));
        state = _.extend(state, {
          'name': name,
          'id': id,
          'owner': owner
        });
        return object = new S.GameObject(new S.HQBehaviour(events), state);
      };
      this.builders[S.Types.Entities.Channel] = function(id, args) {
        var events, name, object, owner, st, state;
        events = args[0];
        owner = args[1];
        name = 'Channel' + id;
        st = new S.ObjectState();
        state = _.extend(st, _this.deepClone(S.Properties.channel, true));
        state = _.extend(state, {
          'name': name,
          'id': id,
          'owner': owner,
          'fields': []
        });
        return object = new S.GameObject(new S.ChannelBehaviour(events), state);
      };
      this.builders[S.Types.Entities.Player] = function(id, args) {
        var name, player, st, userId;
        userId = args[0];
        st = new S.Player();
        player = _.extend(st, _this.deepClone(S.Properties.player, true));
        name = 'Player_' + id;
        return _.extend(player, {
          'name': name,
          'id': id,
          'userId': userId
        });
      };
      this.builders[S.Types.Resources.Food] = function(id, args) {
        var events, name, object, owner, st, state;
        events = args[0];
        owner = args[1];
        name = 'Food' + id;
        st = new S.ObjectState();
        state = _.extend(st, _this.deepClone(S.Properties.resource, true));
        state = _.extend(state, {
          'name': name,
          'id': id,
          'owner': owner,
          'type': S.Types.Resources.Food
        });
        return object = new S.GameObject(new S.ResourceBehaviour(S.Types.Resources.Food, events), state);
      };
      this.builders[S.Types.Resources.Gold] = function(id, args) {
        var events, name, object, owner, st, state;
        events = args[0];
        owner = args[1];
        name = 'Gold' + id;
        st = new S.ObjectState();
        state = _.extend(st, _this.deepClone(S.Properties.resource, true));
        state = _.extend(state, {
          'name': name,
          'id': id,
          'owner': owner,
          'type': S.Types.Resources.Gold
        });
        return object = new S.GameObject(new S.ResourceBehaviour(S.Types.Resources.Gold, events), state);
      };
      this.builders[S.Types.Resources.Resources] = function(id, args) {
        var events, name, object, owner, st, state;
        events = args[0];
        owner = args[1];
        name = 'Resources' + id;
        st = new S.ObjectState();
        state = _.extend(st, _this.deepClone(S.Properties.resource, true));
        state = _.extend(state, {
          'name': name,
          'id': id,
          'owner': owner,
          'type': S.Types.Resources.Resources
        });
        return object = new S.GameObject(new S.ResourceBehaviour(S.Types.Resources.Resources, events), state);
      };
      _.extend(this.builders, S.SignalFactory.builders);
    }

    ObjectFactory.prototype.build = function() {
      var args, kind, uid;
      kind = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!kind) {
        console.error("kind is undefined");
      }
      if (!_.isFunction(this.builders[kind])) {
        throw Error(kind + " is not a valid Entity type");
      }
      uid = _.uniqueId();
      return this.builders[kind](uid, args);
    };

    ObjectFactory.prototype.deepClone = function(obj, deep) {
      var func, isArr,
        _this = this;
      if (!_.isObject(obj) || _.isFunction(obj)) {
        return obj;
      }
      if (_.isDate(obj)) {
        return new Date(obj.getTime());
      }
      if (_.isRegExp(obj)) {
        return new RegExp(obj.source, obj.toString().replace(/.*\//, ""));
      }
      isArr = _.isArray(obj) || _.isArguments(obj);
      if (deep) {
        func = function(memo, value, key) {
          if (isArr) {
            memo.push(_this.deepClone(value, true));
          } else {
            memo[key] = _this.deepClone(value, true);
          }
          return memo;
        };
        return _.reduce(obj, func, (isArr ? [] : {}));
      } else {
        if (isArr) {
          return slice.call(obj);
        } else {
          return _.extend({}, obj);
        }
      }
    };

    return ObjectFactory;

  })();

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    exports = module.exports = new ObjectFactory();
  } else {
    window.S.ObjectFactory = new ObjectFactory();
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var Map, S, cloneextend, exports, util, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  S = {};

  if (typeof require !== "undefined" && require !== null) {
    _ = require('underscore');
    S.Field = require('../objects/Field');
    S.ObjectFactory = require('../config/ObjectFactory');
    S.Types = require('../config/Types');
    S.HeightMap = require('./HeightMap');
    cloneextend = require('cloneextend');
    util = require('util');
  } else {
    _ = window._;
    S.Field = window.S.Field;
    S.ObjectFactory = window.S.ObjectFactory;
    S.Types = window.S.Types;
    S.HeightMap = window.S.HeightMap;
    cloneextend = window.cloneextend;
  }

  Map = (function() {

    function Map(eventBus, minWidth, maxWidth, nonUser, startingFields) {
      var initializeField, mapHeight, mapWidth, x, y, _i, _j, _ref, _ref1,
        _this = this;
      this.eventBus = eventBus;
      this.minWidth = minWidth;
      this.maxWidth = maxWidth;
      this.nonUser = nonUser;
      this.startingFields = startingFields;
      this.iterateFields = __bind(this.iterateFields, this);

      this.fields = {};
      this.diffRows = this.maxWidth - this.minWidth;
      this.directionModUpper = [[-1, -1], [0, -1], [1, 0], [1, 1], [0, 1], [-1, 0]];
      this.directionModLower = [[0, -1], [1, -1], [1, 0], [0, 1], [-1, 1], [-1, 0]];
      for (y = _i = 0, _ref = 2 * this.diffRows + 1; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = this.maxWidth - Math.abs(this.diffRows - y); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          this.addField({}, x, y);
        }
      }
      this.flatteningFactor = 1;
      this.smoothingPasses = 16;
      this.groundLevel = 0;
      mapHeight = this.np2(16 * (2 * this.diffRows + 1));
      mapWidth = this.np2(16 * (this.maxWidth + 1));
      this.heightMapSize = Math.max(mapHeight, mapWidth);
      initializeField = function(o, x, y) {
        return _this.fields[y][x] = new S.Field(x, y);
      };
      this.iterateFields(initializeField);
    }

    Map.prototype.determineTerrain = function(x, y) {
      var height, hx, hy;
      hy = y;
      hx = x + Math.abs(this.diffRows - y);
      height = this.heightMap.get_cell(8 * hx, 8 * hy);
      if (height < 40) {
        return [S.Types.Terrain.Sand];
      } else if (height < 48) {
        return [S.Types.Terrain.Sand];
      } else if (height < 64) {
        return [S.Types.Terrain.Sand];
      } else if (height < 80) {
        return [S.Types.Terrain.Sand];
      } else if (height < 100) {
        return [S.Types.Terrain.Grass];
      } else if (height < 120) {
        return [S.Types.Terrain.Grass];
      } else if (height < 170) {
        return [S.Types.Terrain.Grass];
      } else if (height < 180) {
        return [S.Types.Terrain.Grass, S.Types.Terrain.Rocks];
      } else if (height < 200) {
        return [S.Types.Terrain.Rocks];
      } else {
        return [S.Types.Terrain.Snow];
      }
    };

    Map.prototype.scaleHeightMap = function() {
      var x, y, _i, _ref, _results;
      _results = [];
      for (x = _i = 0, _ref = this.heightMapSize; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (y = _j = 0, _ref1 = this.heightMapSize; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
            _results1.push(this.heightMap.map[x][y] = this.scaleHeight(this.heightMap.map[x][y]));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Map.prototype.scaleHeight = function(h) {
      return this.flatteningFactor * (h - this.groundLevel);
    };

    Map.prototype.smoothenTheTerrain = function(n) {
      var adjSec, i, newHeightMap, secTotal, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2;
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        newHeightMap = [];
        for (x = _j = 0, _ref = this.heightMapSize; 0 <= _ref ? _j < _ref : _j > _ref; x = 0 <= _ref ? ++_j : --_j) {
          newHeightMap[x] = [];
        }
        for (x = _k = 0, _ref1 = this.heightMapSize; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; x = 0 <= _ref1 ? ++_k : --_k) {
          for (y = _l = 0, _ref2 = this.heightMapSize; 0 <= _ref2 ? _l < _ref2 : _l > _ref2; y = 0 <= _ref2 ? ++_l : --_l) {
            adjSec = 0;
            secTotal = 0;
            if (x - 1 >= 0) {
              adjSec++;
              secTotal += this.heightMap.map[x - 1][y];
              if (y + 1 < this.heigtMapSize) {
                adjSec++;
                secTotal += this.heightMap.map[x - 1][y + 1];
              }
              if (y - 1 >= 0) {
                adjSec++;
                secTotal += this.heightMap.map[x - 1][y - 1];
              }
            }
            if (x + 1 < this.heightMapSize) {
              adjSec++;
              secTotal += this.heightMap.map[x + 1][y];
              if (y + 1 < this.heigtMapSize) {
                adjSec++;
                secTotal += this.heightMap.map[x + 1][y + 1];
              }
              if (y - 1 >= 0) {
                adjSec++;
                secTotal += this.heightMap.map[x + 1][y - 1];
              }
            }
            if (y + 1 < this.heigtMapSize) {
              adjSec++;
              secTotal += this.heightMap.map[x][y + 1];
            }
            if (y - 1 >= 0) {
              adjSec++;
              secTotal += this.heightMap.map[x][y - 1];
            }
            newHeightMap[x][y] = (this.heightMap.map[x][y] + secTotal / adjSec) / 2;
          }
        }
        this.heightMap.map = newHeightMap.slice(0);
      }
      return null;
    };

    Map.prototype.np2 = function(x) {
      return Math.pow(2, Math.round(Math.log(x) / Math.log(2)));
    };

    Map.prototype.initialise = function() {
      var initializeResource, initializeTerrain,
        _this = this;
      this.heightMap = new S.HeightMap(this.heightMapSize + 1);
      this.heightMap.run();
      this.scaleHeightMap();
      initializeTerrain = function(o, x, y) {
        return _this.fields[y][x].terrain = _this.determineTerrain(x, y);
      };
      this.iterateFields(initializeTerrain);
      initializeResource = function(o, x, y) {
        var chance, foodTerrains, goldTerrains, kind, life, res, resource, resourcesTerrains, skip;
        skip = _.any(_this.startingFields, function(o) {
          var x2, y2;
          x2 = o[0], y2 = o[1];
          return x2 === x && y2 === y;
        });
        if (skip) {
          return null;
        }
        chance = 0.72;
        res = Math.random();
        resourcesTerrains = [S.Types.Terrain.Sand, S.Types.Terrain.Rocks, S.Types.Terrain.Grass];
        goldTerrains = [S.Types.Terrain.Sand, S.Types.Terrain.Rocks];
        foodTerrains = [S.Types.Terrain.Grass, S.Types.Terrain.Water];
        if (res < chance) {
          kind = '';
          life = 0;
          if (res > chance / 2) {
            if ((_.intersection(_this.fields[y][x].terrain, resourcesTerrains)).length > 0) {
              kind = S.Types.Resources.Gold;
              life = S.Types.Resources.Lifes[0]();
            }
          } else if (res > chance / 3) {
            if ((_.intersection(_this.fields[y][x].terrain, goldTerrains)).length > 0) {
              kind = S.Types.Resources.Gold;
              life = S.Types.Resources.Lifes[0]();
            }
          } else {
            if ((_.intersection(_this.fields[y][x].terrain, foodTerrains)).length > 0) {
              kind = S.Types.Resources.Food;
              life = S.Types.Resources.Lifes[1]();
            }
          }
          if (kind) {
            resource = S.ObjectFactory.build(kind, _this.eventBus, _this.nonUser);
            resource.state.life = life;
            return _this.addResource(resource, x, y);
          }
        }
      };
      return this.iterateFields(initializeResource);
    };

    Map.prototype.directionModificators = function(x, y, dir) {
      var mod;
      if (y < this.diffRows || (y === this.diffRows && dir < 3)) {
        mod = this.directionModUpper[dir];
      } else if (y > this.diffRows || (y === this.diffRows && dir >= 3)) {
        mod = this.directionModLower[dir];
      }
      return [x + mod[0], y + mod[1]];
    };

    Map.prototype.directionGet = function(x1, y1, x2, y2) {
      var dir, mods, xn, yn;
      xn = x2 - x1;
      yn = y2 - y1;
      if (y1 < this.diffRows || (y1 === this.diffRows && y2 < y1)) {
        mods = this.directionModUpper;
        dir = -1;
        _.each(mods, function(o, i) {
          var xMod, yMod;
          xMod = o[0], yMod = o[1];
          if (xMod === xn && yMod === yn) {
            dir = i;
            return {};
          }
        });
      } else if (y1 > this.diffRows || (y1 === this.diffRows && y2 >= y1)) {
        mods = this.directionModLower;
        dir = -1;
        _.each(mods, function(o, i) {
          var xMod, yMod;
          xMod = o[0], yMod = o[1];
          if (xMod === xn && yMod === yn) {
            dir = i;
            return {};
          }
        });
      }
      return dir;
    };

    Map.prototype.addField = function(field, x, y) {
      var _base, _ref;
      if ((_ref = (_base = this.fields)[y]) == null) {
        _base[y] = {};
      }
      return this.fields[y][x] = field;
    };

    Map.prototype.addTerrain = function(terrain, x, y) {
      var _base, _ref;
      if ((_ref = (_base = this.fields)[y]) == null) {
        _base[y] = {};
      }
      return this.fields[y][x].terrain = terrain;
    };

    Map.prototype.addResource = function(resource, x, y) {
      resource.behaviour.eventBus = this.eventBus;
      resource.state.field = this.fields[y][x];
      return this.fields[y][x].resource = resource;
    };

    Map.prototype.addPlatform = function(platform, x, y) {
      var channel, dir, nDir, _ref;
      platform.behaviour.eventBus = this.eventBus;
      platform.state.field = this.fields[y][x];
      this.fields[y][x].platform = platform;
      _ref = this.fields[y][x].channels;
      for (dir in _ref) {
        channel = _ref[dir];
        nDir = (+dir + 3) % 6;
        platform.state.routing[dir].object = channel;
        channel.state.routing[nDir].object = platform;
        channel.trigger('route');
      }
      return platform.trigger('route');
    };

    Map.prototype.addChannel = function(channel, x, y, k) {
      var channelRouting, nK, nX, nY, routingAddChannel, _base, _base1, _ref, _ref1, _ref2,
        _this = this;
      channel.behaviour.eventBus = this.eventBus;
      if ((_ref = (_base = this.fields)[y]) == null) {
        _base[y] = {};
      }
      if ((_ref1 = (_base1 = this.fields[y][x]).channels) == null) {
        _base1.channels = {};
      }
      channel.state.fields.push(this.fields[y][x]);
      channel.state.direction = k;
      this.fields[y][x].channels[k] = channel;
      _ref2 = this.directionModificators(x, y, k), nX = _ref2[0], nY = _ref2[1];
      nK = (k + 3) % 6;
      this.addReverseChannel(channel, nX, nY, nK);
      routingAddChannel = function(x, y, k) {
        if (_this.fields[y][x].platform.type != null) {
          nK = (k + 3) % 6;
          _this.fields[y][x].platform.state.routing[k].object = channel;
          channel.trigger('route');
          channel.state.routing[nK].object = _this.fields[y][x].platform;
          return _this.fields[y][x].platform.trigger('route');
        }
      };
      channelRouting = function(x, y, k) {
        var channels, dest, nIndex;
        if (!(_this.fields[y][x].platform.type != null)) {
          channels = [];
          _.each(_this.getField(x, y).channels, function(route, index) {
            if ((+index) !== k) {
              return channels.push([route, index]);
            }
          });
          dest = channels[0];
          if (dest != null) {
            dest[1] = +dest[1];
            nK = (k + 3) % 6;
            nIndex = (dest[1] + 3) % 6;
            dest[0].state.routing[nIndex].object = channel;
            dest[0].trigger('route');
            channel.state.routing[nK].object = dest[0];
            return channel.trigger('route');
          }
        }
      };
      routingAddChannel(x, y, k);
      routingAddChannel(nX, nY, nK);
      channelRouting(x, y, k);
      return channelRouting(nX, nY, nK);
    };

    Map.prototype.addReverseChannel = function(channel, x, y, k) {
      var _base, _base1, _ref, _ref1;
      if ((_ref = (_base = this.fields)[y]) == null) {
        _base[y] = {};
      }
      if ((_ref1 = (_base1 = this.fields[y][x]).channels) == null) {
        _base1.channels = {};
      }
      this.fields[y][x].channels[k] = channel;
      return channel.state.fields.push(this.fields[y][x]);
    };

    Map.prototype.extractGameState = function() {
      var gameState,
        _this = this;
      gameState = {};
      gameState.heightMap = this.heightMap.map;
      this.iterateFields(function(field, x, y) {
        var channels, dir, exportState, platform, resource, route, signal, terrain, _i, _len, _ref, _ref1, _ref2;
        if ((_ref = gameState[y]) == null) {
          gameState[y] = {};
        }
        channels = {};
        if (_.keys(field.channels).length > 0) {
          _.each(field.channels, function(channel, direction) {
            var dir, i, newChannel, route, signal, _i, _len, _ref1, _ref2;
            if (!(_.isEmpty(channel))) {
              newChannel = cloneextend.cloneuptolevel(channel.state, 4);
              _ref1 = newChannel.routing;
              for (dir in _ref1) {
                route = _ref1[dir];
                newChannel.routing[dir].object = {};
              }
              newChannel.fields = [];
              _ref2 = newChannel.signals;
              for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
                signal = _ref2[i];
                signal.source.field = {};
                signal.events = {};
              }
              return channels[direction] = newChannel;
            } else {
              return channels[direction] = {};
            }
          });
        }
        platform = {};
        if (field.platform.type != null) {
          platform = cloneextend.cloneuptolevel(field.platform.state, 3);
          _ref1 = platform.routing;
          for (dir in _ref1) {
            route = _ref1[dir];
            platform.routing[dir].object = {};
          }
          platform.field = {};
          _ref2 = platform.signals;
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            signal = _ref2[_i];
            signal.source.field = {};
            signal.events = {};
          }
        }
        resource = {};
        if (field.resource.type != null) {
          resource = cloneextend.cloneuptolevel(field.resource.state, 3);
          resource.field = {};
        }
        terrain = field.terrain;
        exportState = {
          channels: channels,
          platform: platform,
          resource: resource,
          terrain: terrain
        };
        return gameState[y][x] = exportState;
      });
      return gameState;
    };

    Map.prototype.importGameState = function(gameState) {
      var initializeField,
        _this = this;
      this.heightMap = new S.HeightMap(this.heightMapSize + 1);
      this.heightMap.map = gameState.heightMap;
      initializeField = function(o, x, y) {
        return _this.fields[y][x] = new S.Field(x, y);
      };
      this.iterateFields(initializeField);
      this.iterateFields(function(field, x, y) {
        var channel, direction, newChannel, newField, platform, resource, _ref, _results;
        newField = gameState[y][x];
        _this.addTerrain(newField.terrain, x, y);
        if (newField.platform.id != null) {
          platform = S.ObjectFactory.build(newField.platform.type, _this.eventBus, {});
          _.extend(platform.state, newField.platform);
          _this.addPlatform(platform, x, y);
        }
        if (newField.resource.id != null) {
          resource = S.ObjectFactory.build(newField.resource.type, _this.eventBus, {});
          _.extend(resource.state, newField.resource);
          _this.addResource(resource, x, y);
        }
        _ref = newField.channels;
        _results = [];
        for (direction in _ref) {
          channel = _ref[direction];
          _results.push((newChannel = S.ObjectFactory.build(channel.type, _this.eventBus, {}), _.extend(newChannel.state, channel), _this.addChannel(newChannel, x, y, +direction)));
        }
        return _results;
      });
      return null;
    };

    Map.prototype.getChannel = function(x, y, k) {
      var field;
      field = this.getField(x, y);
      if (field != null) {
        return field.channels[k];
      } else {
        return null;
      }
    };

    Map.prototype.getField = function(x, y) {
      if (this.fields[y] != null) {
        return this.fields[y][x];
      }
      return null;
    };

    Map.prototype.iterateFields = function(f) {
      var x, y, _i, _j, _ref, _ref1;
      for (y = _i = 0, _ref = 2 * this.diffRows + 1; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = this.maxWidth - Math.abs(this.diffRows - y); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          f(this.fields[y][x], x, y);
        }
      }
      return null;
    };

    return Map;

  })();

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    exports = module.exports = Map;
  } else {
    window.S.Map = Map;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var GameManager, S, exports, _;

  S = {};

  if (typeof require !== "undefined" && require !== null) {
    _ = require('underscore');
    S.Field = require('../objects/Field');
    S.ObjectFactory = require('../config/ObjectFactory');
    S.Types = require('../config/Types');
    S.Map = require('./Map');
  } else {
    _ = window._;
    S.Field = window.S.Field;
    S.ObjectFactory = window.S.ObjectFactory;
    S.Types = window.S.Types;
    S.Map = window.S.Map;
  }

  GameManager = (function() {

    function GameManager(eventBus, map) {
      this.eventBus = eventBus;
      this.map = map;
      this.players = {};
      this.startingPoints = {};
    }

    GameManager.prototype.addPlayer = function(playerObject, position) {
      this.players[playerObject.id] = playerObject;
      return this.startingPoints[playerObject.id] = position;
    };

    GameManager.prototype.startGame = function() {
      return this.map.iterateFields(function(o, x, y) {
        var channel, dir, _ref, _results;
        if (o.platform.type != null) {
          o.platform.trigger('produce');
          o.platform.trigger('route');
        }
        _ref = o.channels;
        _results = [];
        for (dir in _ref) {
          channel = _ref[dir];
          if (channel != null) {
            _results.push(channel.trigger('route'));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
    };

    GameManager.prototype.stopGame = function() {
      return this.map.iterateFields(function(o) {
        if ((o.resource.type != null) && o.resource.behaviour.PID) {
          return clearInterval(o.resource.behaviour.PID);
        }
      });
    };

    GameManager.prototype.addHQ = function(HQ, position) {
      var x, y;
      x = position[0], y = position[1];
      return this.map.addPlatform(HQ, x, y);
    };

    GameManager.prototype.getDimensions = function() {
      return [this.map.minWidth, this.map.maxWidth];
    };

    return GameManager;

  })();

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    exports = module.exports = GameManager;
  } else {
    window.S.GameManager = GameManager;
  }

}).call(this);
