// Generated by CoffeeScript 1.3.3
(function() {
  var Communicator, Negotiator,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Communicator = (function() {

    function Communicator(host) {
      var self;
      this.host = host;
      this.leave = __bind(this.leave, this);

      this.join = __bind(this.join, this);

      this.passClientEvent = __bind(this.passClientEvent, this);

      this.parseClientEvent = __bind(this.parseClientEvent, this);

      this.trigger = __bind(this.trigger, this);

      this.off = __bind(this.off, this);

      this.on = __bind(this.on, this);

      this.handleReconnectFailed = __bind(this.handleReconnectFailed, this);

      this.handleReconnecting = __bind(this.handleReconnecting, this);

      this.handleReconnected = __bind(this.handleReconnected, this);

      this.handlePing = __bind(this.handlePing, this);

      this.handleError = __bind(this.handleError, this);

      this.handleDisconnected = __bind(this.handleDisconnected, this);

      this.handleConnecting = __bind(this.handleConnecting, this);

      this.handleConnectFailed = __bind(this.handleConnectFailed, this);

      this.handleConnected = __bind(this.handleConnected, this);

      self = this;
      this.com = {};
      _.extend(this.com, Backbone.Events);
      this.id = null;
      if (this.host != null) {
        this.host = 'http://localhost:8080';
      }
      this.socket = io.connect(this.host, this.socketConfig);
      this.socket.on('connecting', this.handleConnecting);
      this.socket.on('connect', this.handleConnected);
      this.socket.on('connect_failed', this.handleConnectFailed);
      this.socket.on('disconnect', this.handleDisconnected);
      this.socket.on('error', this.handleError);
      this.socket.on('ping', this.handlePing);
      this.socket.on('reconnect', this.handleReconnected);
      this.socket.on('reconnecting', this.handleReconnecting);
      this.socket.on('reconnect_failed', this.handleReconnectFailed);
      this.com.on('all', this.parseClientEvent, this, false);
    }

    /*
      communication layer handlers for communication events
      other objects can subscribe anyway using comuunicator.on event, fn
    */


    Communicator.prototype.handleConnected = function() {
      return console.info("Communicator: Successfully connected to the server.");
    };

    Communicator.prototype.handleConnectFailed = function(reason) {
      return console.error('Communicator: Unable to connect Socket.IO', reason);
    };

    Communicator.prototype.handleConnecting = function(transport) {
      return console.info("Communicator: Connecting " + transport);
    };

    Communicator.prototype.handleDisconnected = function() {
      return console.info("Communicator: Disconnected from the server.");
    };

    Communicator.prototype.handleError = function(reason) {
      return console.error('Communicator: Unable to connect Socket.IO', reason);
    };

    Communicator.prototype.handlePing = function() {
      var _this = this;
      this.socket.emit('pong');
      return this.socket.once('lag', function(lag) {
        return _this.lag = lag;
      });
    };

    Communicator.prototype.handleReconnected = function(transport, attempts) {};

    Communicator.prototype.handleReconnecting = function(delay, attempts) {};

    Communicator.prototype.handleReconnectFailed = function() {};

    /*
      extend functions to handle events on both communicator and server
    */


    Communicator.prototype.on = function(events, callback, context, socket) {
      this.com.on(events, callback);
      if (!(socket != null) || socket) {
        return this.socket.on(events, callback);
      }
    };

    Communicator.prototype.off = function(events, callback, context, socket) {
      this.com.off(events, callback);
      if (!(socket != null) || socket) {
        return this.socket.removeListener(events, callback);
      }
    };

    Communicator.prototype.trigger = function() {
      return this.com.trigger.apply(this.com, arguments);
    };

    Communicator.prototype.parseClientEvent = function() {
      console.log("Communicator: parse ", arguments);
      if (event === 'disconnect') {
        return this.socket.disconnect();
      } else {
        return this.passClientEvent.apply(this, arguments);
      }
    };

    Communicator.prototype.passClientEvent = function() {
      console.log("Communicator: pass");
      return this.socket.emit.apply(this.socket, arguments);
    };

    Communicator.prototype.join = function(channel) {
      var _this = this;
      return this.socket.emit('join:channel', channel, function(confirm) {
        if (confirm) {
          _this.channel = channel;
          console.log("Communicator: joined channel " + channel);
          return _this.com.trigger('joined', channel);
        } else {
          _this.com.trigger('join_failed');
          return console.error('Communicator: server does not love you');
        }
      });
    };

    Communicator.prototype.leave = function(channel) {
      var _this = this;
      if (this.channel === channel) {
        return this.socket.emit('leave:channel', channel, function(confirm) {
          _this.com.trigger('left');
          return _this.channel = '';
        });
      }
    };

    return Communicator;

  })();

  window.S.Communicator = Communicator;

  Negotiator = (function() {

    function Negotiator(communicator) {
      var initiate, self, uiLoaded,
        _this = this;
      this.communicator = communicator;
      self = this;
      this.started = false;
      _.extend(this, Backbone.Events);
      this.myPlayer = {};
      this.game = {};
      this.renderer = {};
      window.loader = this.loader = new S.Loader();
      this.timer = new S.Timer(this);
      this.timer.setTime(900);
      $.when(this.loader.start()).then(function() {});
      this.loading = new $.Deferred();
      this.on('move:signal', function(xy, dir) {
        return this.renderer.moveSignal(xy[0], xy[1], dir);
      });
      this.on('full:channel', function(fields) {
        var p1, p2, x1, y1;
        p1 = this.ui.getPoint(fields[0].xy[0], fields[0].xy[1]);
        p2 = this.ui.getPoint(fields[1].xy[0], fields[1].xy[1]);
        x1 = (p2.x + p1.x) / 2;
        y1 = ((p2.y + p1.y) / 2) + 10;
        if (this.renderer.boardDR.contains(this.renderer.boardDR.roads, fields[0] || this.renderer.boardDR.contains(this.renderer.boardDR.roads, fields[1]))) {
          return this.ui.showTextBubble("Channel full", x1, y1, {
            color: [159, 17, 27, 1]
          });
        }
      });
      this.on('owner:channel', function(dest, src, ownerid, status) {
        var field, field2;
        field = (_.intersection(dest, src))[0];
        field2 = (_.difference(dest, src))[0];
        this.renderer.captureOwnership(field.xy[0], field.xy[1], ownerid, 1);
        if (!(field2.platform.type != null)) {
          console.log("field2", field2);
          return this.renderer.captureOwnership(field2.xy[0], field2.xy[1], ownerid, 2);
        }
      });
      this.on('owner:platform', function(xy, ownerid) {
        return this.renderer.captureOwnership(xy[0], xy[1], ownerid, 1);
      });
      this.on('player:lost', function(player) {
        return this.communicator.trigger('end:game', player);
      });
      this.on('time:out', function() {
        var own1, own2, player,
          _this = this;
        own1 = 0;
        own2 = 0;
        this.game.map.iterateFields(function(field, i, j) {
          var _ref;
          if ((((_ref = _this.renderer.boardDR.owner[i]) != null ? _ref[j] : void 0) != null) && !_this.renderer.boardDR.contains(_this.renderer.boardDR.ownership, [i, j])) {
            return own2++;
          } else if (_this.renderer.boardDR.contains(_this.renderer.boardDR.ownership, [i, j])) {
            return own1++;
          }
        });
        console.log("chuj", own1, own2);
        if (own1 < own2) {
          return this.communicator.trigger('end:game', this.myPlayer, "lose");
        } else if (own1 === own2) {
          return this.communicator.trigger('end:game', this.myPlayer, "tie");
        } else {
          player = _filter(this.game.players, function(a) {
            return a.id !== this.myPlayer.id;
          });
          return this.communicator.trigger('end:game', player, "win");
        }
      });
      this.on('resource:produce', function(xy, amount, type) {
        var p;
        p = this.ui.getPoint(xy[0], xy[1]);
        if (this.renderer.boardDR.contains(this.renderer.boardDR.roads, xy)) {
          return this.ui.showTextBubble("-" + amount, p.x + 40, p.y + 20);
        }
      });
      this.on('resource:receive', function(xy, amount, type) {
        var name, p;
        p = this.ui.getPoint(xy[0], xy[1]);
        name = S.Types.Resources.Names[type - 6];
        if (this.renderer.boardDR.contains(this.renderer.boardDR.roads, xy)) {
          this.ui.showTextBubble("+" + amount + " " + name, p.x + 40, p.y + 20);
        }
        return this.ui.showResources(amount, type);
      });
      this.on('build:platform', function(x, y, type, owner) {
        var canAfford, cost, i, p, userHas;
        p = _this.ui.getPoint(x, y);
        cost = S.Types.Events.Build.Platform.cost;
        userHas = _this.myPlayer.resources;
        canAfford = _.all(cost, function(v, k) {
          return userHas[k] >= v;
        });
        if (canAfford) {
          i = 0;
          _.each(cost, function(v, k) {
            _this.myPlayer.spendResources(k, v);
            if (_this.renderer.boardDR.contains(_this.renderer.boardDR.roads, [x, y])) {
              _this.ui.showTextBubble("-" + v + " " + k, p.x + 40, p.y + 20 + i * 20);
            }
            return i++;
          });
          _this.buildPlatform(x, y, type, _this.myPlayer);
          _this.communicator.trigger('send:build:platform', x, y, type, _this.myPlayer);
          _this.ui.showResources(0, 6);
          return _this.ui.showResources(0, 7);
        } else if (_this.renderer.boardDR.contains(_this.renderer.boardDR.roads, [x, y])) {
          return _this.ui.showTextBubble("Not enough resources", p.x + 40, p.y + 20, {
            color: [159, 17, 27, 1]
          });
        }
      });
      this.on('build:channel', function(x, y, k, owner) {
        var canAfford, cost, i, p, userHas;
        p = _this.ui.getPoint(x, y);
        cost = S.Types.Events.Build.Channel.cost;
        userHas = _this.myPlayer.resources;
        canAfford = _.all(cost, function(v, k) {
          return userHas[k] >= v;
        });
        if (canAfford) {
          i = 0;
          _.each(cost, function(v, k) {
            _this.myPlayer.spendResources(k, v);
            if (_this.renderer.boardDR.contains(_this.renderer.boardDR.roads, [x, y])) {
              _this.ui.showTextBubble("-" + v + " " + k, p.x + 40, p.y + 20 + i * 20);
            }
            return i++;
          });
          _this.buildChannel(x, y, k, _this.myPlayer);
          _this.communicator.trigger('send:build:channel', x, y, k, _this.myPlayer);
          _this.ui.showResources(0, 6);
          return _this.ui.showResources(0, 7);
        } else if (_this.renderer.boardDR.contains(_this.renderer.boardDR.roads, [x, y])) {
          return _this.ui.showTextBubble("Not enough resources", p.x + 40, p.y + 20, {
            color: [159, 17, 27, 1]
          });
        }
      });
      this.on('routing', function(obj, routing) {
        var dir, ret, route, routingValues;
        _.extend(obj.platform.state.routing, routing);
        obj.platform.trigger('route');
        _.each(routing, function(route) {
          if (route.type != null) {
            return route.object.trigger('route');
          }
        });
        routingValues = {};
        for (dir in routing) {
          route = routing[dir];
          ret = {
            "in": route["in"],
            out: route.out
          };
          routingValues[dir] = ret;
        }
        console.log('[Negotiator] new routing: ', routingValues);
        return _this.communicator.trigger('send:routing', obj.xy[0], obj.xy[1], routingValues, obj.platform.state.owner);
      });
      this.on('scroll', this.setScroll);
      this.on('scroll', this.setViewport);
      this.communicator.on('new:player', function(playerObject, position, HQState) {
        var HQ, pObject, x, y;
        console.log('[Negotiator] new player');
        pObject = S.ObjectFactory.build(S.Types.Entities.Player);
        playerObject = _.extend(pObject, playerObject);
        _this.renderer.addPlayer(playerObject.id);
        HQ = S.ObjectFactory.build(S.Types.Entities.Platforms.HQ, _this, playerObject);
        HQ.state = HQState;
        HQ.state.owner = playerObject;
        _this.game.addPlayer(playerObject, position);
        _this.game.addHQ(HQ, position);
        x = position[0], y = position[1];
        _this.renderer.buildPlatform(x, y, HQ);
        _this.renderer.changeOwnership(x, y, playerObject.id);
        return _this.renderer.loading.notify(250);
      });
      this.communicator.on('foreign:build:platform', function(x, y, type, owner) {
        if (owner.id !== _this.myPlayer.id) {
          return _this.buildPlatform(x, y, type, owner);
        }
      });
      this.communicator.on('foreign:build:channel', function(x, y, k, owner) {
        if (owner.id !== _this.myPlayer.id) {
          return _this.buildChannel(x, y, k, owner);
        }
      });
      this.communicator.on('foreign:routing', function(x, y, routing, owner) {
        var dir, field, route, routes, _results;
        if (owner.id !== _this.myPlayer.id) {
          field = _this.getField(x, y);
          routes = field.platform.state.routing;
          _results = [];
          for (dir in routing) {
            route = routing[dir];
            routes[dir]["in"] = route["in"];
            _results.push(routes[dir].out = route.out);
          }
          return _results;
        }
      });
      this.communicator.on('state:sync', function(players, startingPoints, state) {
        var field, i, id, myPlayer, pObject, player, point, x, y;
        _this.game.map.importGameState(state);
        for (id in players) {
          player = players[id];
          pObject = S.ObjectFactory.build(S.Types.Entities.Player, null, null);
          myPlayer = _.extend(pObject, player);
          _this.game.players[id] = myPlayer;
        }
        for (i in startingPoints) {
          point = startingPoints[i];
          x = point[0], y = point[1];
          field = _this.getField(x, y);
          _this.game.map.fields[y][x].platform.state.owner = _this.game.players[+i];
        }
        _this.game.startingPoints = startingPoints;
        return _this.renderer.setupBoard(_this.game.map);
      });
      this.communicator.on('game:over', function(player, status) {
        console.log('GameOver', player);
        if (status === "tie") {
          return _this.ui.gameTied();
        } else if (player.id === _this.myPlayer.id) {
          return _this.ui.gameOver();
        } else {
          return _this.ui.gameWon();
        }
      });
      this.communicator.on('time:sync', function(time) {
        var lag;
        lag = 0;
        if (_this.communicator.lag != null) {
          lag = (+_this.communicator.lag) / 1000;
        }
        return _this.timer.setTime(time - Math.round(2 * lag));
      });
      this.communicator.on('players:all:ready', function() {
        console.log('[Negotiator] all players loaded');
        _this.started = true;
        _this.startGame();
        return self.timer.start();
      });
      initiate = new $.Deferred();
      uiLoaded = new $.Deferred();
      $.when(initiate.promise()).done(this.setupUI(uiLoaded));
      $.when(uiLoaded.promise()).done(function() {
        console.log('UI has been loaded');
        return _this.communicator.trigger('set:user:ready', _this.user.id);
      });
      this.initiateConnection(initiate);
    }

    Negotiator.prototype.initiateConnection = function(dfd) {
      var getGame, getUser,
        _this = this;
      getUser = new $.Deferred();
      getGame = new $.Deferred();
      getUser.done(function(user) {
        console.log('[Negotitator] user: ', user);
        _this.user = user;
        return _this.communicator.trigger('get:user:game', _this.user.id);
      });
      getGame.done(function(game) {
        var lag, playerObject;
        lag = 0;
        if (_this.communicator.lag != null) {
          lag = (+_this.communicator.lag) / 1000;
        }
        console.log('[Negotitator] timer time ', game.time - Math.round(2 * lag));
        _this.timer.setTime(game.time - Math.round(2 * lag));
        _this.gameInfo = game;
        playerObject = S.ObjectFactory.build(S.Types.Entities.Player);
        _this.myPlayer = _this.gameInfo.players[_this.user.id].playerObject;
        _this.myPlayer = _.extend(playerObject, _this.myPlayer);
        _this.communicator.join(_this.gameInfo.name);
        return _this.communicator.trigger('get:game:state', _this.gameInfo.name);
      });
      this.communicator.on('user', function(user) {
        return getUser.resolve(user);
      });
      this.communicator.on('user:game', function(game) {
        return getGame.resolveWith(_this, [game]);
      });
      return this.communicator.on('game:state', this.setGameState(dfd));
    };

    Negotiator.prototype.setGameState = function(dfd) {
      var _this = this;
      return function(players, startingPoints, state, minWidth, maxWidth, nonUser) {
        var field, i, id, map, myPlayer, pObject, player, point, x, y;
        console.log('[Negotiator] game state', players, startingPoints, state, minWidth, maxWidth, nonUser);
        map = new S.Map(_this, minWidth, maxWidth, nonUser, _this.gameInfo.typeData.startingPoints);
        map.importGameState(state);
        _this.game = new S.GameManager(_this, map);
        for (id in players) {
          player = players[id];
          pObject = S.ObjectFactory.build(S.Types.Entities.Player, null, null);
          myPlayer = _.extend(pObject, player);
          if (myPlayer.id !== _this.myPlayer.id) {
            _this.game.players[id] = myPlayer;
          } else {
            _this.game.players[id] = _this.myPlayer;
          }
        }
        console.log(_this.game.players);
        for (i in startingPoints) {
          point = startingPoints[i];
          x = point[0], y = point[1];
          field = _this.getField(x, y);
          _this.game.map.fields[y][x].platform.state.owner = _this.game.players[i];
        }
        _this.game.startingPoints = startingPoints;
        return dfd.resolveWith(_this);
      };
    };

    Negotiator.prototype.startGame = function() {
      var requestSync, sync,
        _this = this;
      this.game.startGame();
      sync = function() {
        return _this.communicator.trigger('sync:time', _this.user.id);
      };
      setInterval(sync, 5000);
      return requestSync = function() {
        var hash, mapState, players, shaObj, startingPoints;
        mapState = JSON.stringify(_this.game.map.extractGameState());
        console.log('[Negotiator] successfully converted map state');
        players = JSON.stringify(_this.game.players);
        startingPoints = JSON.stringify(_this.game.startingPoints);
        shaObj = new jsSHA(mapState + players + startingPoints, 'ASCII');
        hash = shaObj.getHash("SHA-512", "B64");
        return _this.communicator.trigger('get:state:sync', _this.gameInfo.name, hash);
      };
    };

    Negotiator.prototype.setupUI = function(dfd) {
      var _this = this;
      return function() {
        var maxWidth, minWidth, _ref;
        _ref = _this.game.getDimensions(), minWidth = _ref[0], maxWidth = _ref[1];
        _this.ui = new S.UIClass(_this, minWidth, maxWidth);
        _this.terrain = new S.Terrain(_this, 'background', minWidth, maxWidth);
        _this.renderer = new S.Renderer(_this, minWidth, maxWidth, _.pluck(_this.game.players, 'id'), _this.myPlayer);
        _this.loader.register(_this.terrain.loading.promise(), 400);
        _this.loader.register(_this.renderer.loading.promise(), 100);
        _this.loader.register(_this.loading.promise(), 100);
        return $.when(_this.renderer.boardLoaded.promise()).done(function() {
          _this.renderer.loading.notify(50);
          _this.renderer.setupBoard(_this.game.map);
          _this.renderer.loading.notify(50);
          _this.terrain.draw();
          _this.renderer.loading.notify(250);
          if (_.keys(_this.game.players).length === 2) {
            _this.renderer.loading.notify(250);
          }
          _this.ui.start();
          return dfd.resolveWith(_this);
        });
      };
    };

    Negotiator.prototype.buildPlatform = function(x, y, type, owner) {
      var platform;
      platform = S.ObjectFactory.build(S.Types.Entities.Platforms.Normal, this, owner, type);
      this.game.map.addPlatform(platform, x, y);
      platform.trigger('produce');
      this.renderer.buildPlatform(x, y, platform);
      return this.renderer.changeOwnership(x, y, owner.id);
    };

    Negotiator.prototype.buildChannel = function(x, y, k, owner) {
      var channel, field, nK, ownerIDs, x2, y2, _i, _ref;
      channel = S.ObjectFactory.build(S.Types.Entities.Channel, this, owner);
      this.game.map.addChannel(channel, x, y, k);
      this.renderer.buildChannel(x, y, k, channel);
      this.renderer.changeOwnership(x, y, owner.id);
      _ref = this.game.map.directionModificators(x, y, k), x2 = _ref[0], y2 = _ref[1];
      nK = (k + 3) % 6;
      this.renderer.buildChannel(x2, y2, nK, channel);
      ownerIDs = [];
      field = this.getField(x2, y2);
      for (k = _i = 0; _i <= 5; k = ++_i) {
        channel = field.channels[k];
        if (channel != null) {
          ownerIDs = _.union(ownerIDs, [channel.state.owner.id]);
        }
      }
      if (_.keys(field.channels).length >= 2 && ownerIDs.length === 1) {
        return this.renderer.changeOwnership(x2, y2, owner.id);
      }
    };

    Negotiator.prototype.nonUserId = function(user) {
      return this.game.map.nonUser.id;
    };

    Negotiator.prototype.directionGet = function(user, x1, y1, x2, y2) {
      return this.game.map.directionGet(x1, y1, x2, y2);
    };

    Negotiator.prototype.getMenu = function(x, y) {
      var field, possibleChannels;
      field = this.getField(x, y);
      if (field != null) {
        if (field.platform.actionMenu != null) {
          return field.platform.actionMenu();
        } else {
          if (_.isEmpty(field.channels)) {
            return null;
          } else if ((_.keys(field.channels)).length > 1 && !(field.platform.type != null)) {
            return [['build:platform'], [[]]];
          } else {
            possibleChannels = this.getPossibleChannels(x, y);
            return [['build:channel', 'build:platform'], [possibleChannels, []]];
          }
        }
      }
    };

    Negotiator.prototype.getField = function(x, y) {
      return this.game.map.getField(x, y);
    };

    Negotiator.prototype.getPossibleChannels = function(x, y) {
      var amountOfChannels, field, k, nField, nX, nY, possibleChannels, _i, _ref;
      field = this.getField(x, y);
      possibleChannels = [];
      for (k = _i = 0; _i <= 5; k = ++_i) {
        _ref = this.game.map.directionModificators(x, y, k), nX = _ref[0], nY = _ref[1];
        nField = this.getField(nX, nY);
        if (nField != null) {
          amountOfChannels = _.keys(nField.channels).length;
          if (!(field.channels[k] != null) && (amountOfChannels < 2 || (nField.platform.type != null))) {
            possibleChannels.push(k);
          }
        }
      }
      console.log("[Negotiator][possible channels]", x, y, possibleChannels);
      return possibleChannels;
    };

    return Negotiator;

  })();

  window.S.Negotiator = Negotiator;

  $(function() {
    var chat, communicator, lobby, location, messages, negotiate;
    if ($('#main.lobby2').length > 0) {
      communicator = new S.Communicator();
      messages = new S.Collections.Messages();
      lobby = new S.Views.LobbyView({
        communicator: communicator,
        collection: messages,
        el: $('#main.lobby2')[0]
      });
      lobby.render();
    }
    if ($('#canvasWrapper').length > 0) {
      location = window.location.href;
      if (_.include(location.split('/'), 'board')) {
        console.log('we\'re on board');
      } else {
        communicator = new S.Communicator();
        negotiate = new S.Negotiator(communicator);
        chat = new S.Chat({
          communicator: communicator,
          collection: new S.Collections.Messages()
        });
        window.negotiate = negotiate;
      }
    }
    return null;
  });

}).call(this);
