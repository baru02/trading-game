// Generated by CoffeeScript 1.3.3
(function() {
  var Timer,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Timer = (function() {

    function Timer(events) {
      this.events = events;
      this.tick = __bind(this.tick, this);

      this.started = false;
      setInterval(this.tick, 1000);
      this.counter = new Text();
      this.counter.textBaseline = "middle";
      this.counter.textAlign = "center";
      this.counter.color = "#fff";
      this.counter.font = "bold 32px 'Cabin', Helvetica,Arial,sans-serif";
      this.counter.x = 100;
      this.counter.y = 25;
      this.canvas = document.getElementById('timer');
      this.stage = new Stage(this.canvas);
      this.stage.addChild(this.counter);
    }

    Timer.prototype.setTime = function(time) {
      return this.time = time;
    };

    Timer.prototype.start = function() {
      return this.started = true;
    };

    Timer.prototype.stop = function() {
      return this.started = false;
    };

    Timer.prototype.endOfTime = function() {
      $(this.canvas).remove();
      this.stage.removeAllChildren();
      return this.events.trigger("time:out");
    };

    Timer.prototype.draw = function() {
      var minutes, seconds, text;
      minutes = Math.floor(this.time / 60);
      seconds = this.time % 60;
      if (minutes < 10) {
        minutes = "0" + minutes;
      }
      if (seconds < 10) {
        seconds = "0" + seconds;
      }
      if (minutes > 0) {
        text = "" + minutes + ":" + seconds;
      } else {
        text = seconds;
      }
      return this.counter.text = text;
    };

    Timer.prototype.tick = function() {
      if (this.started) {
        if (this.time <= 0) {
          this.endOfTime();
        } else if (this.time <= 60) {
          this.time--;
          this.draw();
        } else {
          this.time--;
          this.draw();
        }
        return this.stage.update();
      }
    };

    return Timer;

  })();

  window.S.Timer = Timer;

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var Loader;

  Loader = (function() {

    function Loader() {
      this.weight = 0;
      this.finished = new $.Deferred();
      this.waitingFor = [];
      this.loaded = 0;
      this.sumOfWeights = 1000;
      this.progress = 0;
      this.stepsToDo = 0;
      this.radius = 200;
      this.width = 20;
      this.startColour = [105, 210, 231];
      this.endColour = [250, 105, 0];
      this.currentColour = this.startColour;
      this.loader = new Shape();
      this.text = new Text();
    }

    Loader.prototype.register = function(promise, weight) {
      var self;
      self = this;
      this.waitingFor.push(promise);
      return promise.progress(function(n) {
        return self.load.call(self, n);
      });
    };

    Loader.prototype.load = function(n) {
      this.progress += n;
      return this.loaded = this.sumOfWeights / this.progress;
    };

    Loader.prototype.draw = function() {
      var angle, b, g, nb, ng, nr, r, sb, sg, sr, _ref, _ref1;
      angle = Math.PI * 2 / 100;
      _ref = this.colourStep, sr = _ref[0], sg = _ref[1], sb = _ref[2];
      _ref1 = this.currentColour, r = _ref1[0], g = _ref1[1], b = _ref1[2];
      nr = r + sr;
      ng = g + sg;
      nb = b + sb;
      this.loader.graphics.setStrokeStyle(this.width, 'round').beginStroke("rgb(" + (Math.round(nr)) + ", " + (Math.round(ng)) + ", " + (Math.round(nb)) + ")").arc(this.x, this.y, this.radius, this.angle, this.angle + angle);
      this.text.color = "rgb(" + (Math.round(nr)) + ", " + (Math.round(ng)) + ", " + (Math.round(nb)) + ")";
      this.currentColour = [nr, ng, nb];
      return this.angle += angle;
    };

    Loader.prototype.waitForPlayers = function() {
      return this.text.text = "Waiting for players";
    };

    Loader.prototype.start = function() {
      var b1, b2, b3, canvas, g1, g2, g3, r1, r2, r3, _ref, _ref1;
      canvas = document.getElementById('loader');
      this.stage = new Stage(canvas);
      this.stage.addChild(this.loader);
      this.stage.addChild(this.text);
      this.x = 300;
      this.y = 300;
      this.angle = Math.PI / 2;
      _ref = this.startColour, r1 = _ref[0], g1 = _ref[1], b1 = _ref[2];
      _ref1 = this.endColour, r2 = _ref1[0], g2 = _ref1[1], b2 = _ref1[2];
      r3 = (r2 - r1) / 100;
      g3 = (g2 - g1) / 100;
      b3 = (b2 - b1) / 100;
      this.colourStep = [r3, g3, b3];
      this.text.x = this.x;
      this.text.y = this.y;
      this.text.text = "Loading";
      this.text.textBaseline = "middle";
      this.text.textAlign = "center";
      this.text.color = "rgb(" + (Math.round(r1)) + ", " + (Math.round(g1)) + ", " + (Math.round(b1)) + ")";
      this.text.font = "bold 32px 'Cabin', Helvetica,Arial,sans-serif";
      Ticker.addListener(this);
      this.stage.update();
      return this.finished.promise();
    };

    Loader.prototype.tick = function() {
      if (this.stepsToDo < Math.ceil(this.progress / this.sumOfWeights * 100)) {
        this.draw();
        this.stage.update();
        return this.stepsToDo++;
      } else if (this.progress >= this.sumOfWeights) {
        Ticker.removeListener(this);
        $(".loader").fadeOut(function() {
          return $(this).remove();
        });
        return this.finished.resolve();
      }
    };

    return Loader;

  })();

  window.S.Loader = Loader;

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var Human;

  Human = (function() {

    function Human(events, image, stage, walkDistance, timeForAWalk) {
      var canvas2, myImage,
        _this = this;
      this.events = events;
      if (image == null) {
        image = '/img/traggerSprite.png';
      }
      this.walkDistance = walkDistance != null ? walkDistance : 80;
      this.timeForAWalk = timeForAWalk != null ? timeForAWalk : 1000;
      this.uid = _.uniqueId();
      if (!(stage != null)) {
        canvas2 = document.getElementById('animations');
        this.stage = new Stage(canvas2);
      } else {
        this.stage = stage;
      }
      this.ready = new $.Deferred();
      this.tranferable = new $.Deferred();
      this.walked = new $.Deferred();
      this.transferred = false;
      this.animation = null;
      this.currentAnimation = null;
      this.distance = 0;
      this.hideAtTheEnd = true;
      this.catchUpDistance = 0;
      this.catchUpVX = 0;
      this.catchUpVY = 0;
      this.visible = false;
      myImage = new Image();
      myImage.onload = function() {
        return _this.ready.resolveWith(_this);
      };
      myImage.src = image;
      this.vx = 0;
      this.vy = 0;
      this.data = {
        images: [myImage],
        frames: {
          width: 42,
          height: 42,
          regX: 21,
          regY: 30
        },
        animations: {
          stand0: [0],
          stand1: [5],
          stand2: [10],
          stand3: [15],
          stand4: [20],
          stand5: [25],
          walk0: {
            frames: [1, 2, 3, 4],
            next: "walk0",
            frequency: 2
          },
          walk1: {
            frames: [6, 7, 8, 9],
            next: "walk1",
            frequency: 2
          },
          walk2: {
            frames: [11, 12, 13, 14],
            next: "walk2",
            frequency: 2
          },
          walk3: {
            frames: [16, 17, 18, 19],
            next: "walk3",
            frequency: 2
          },
          walk4: {
            frames: [21, 22, 23, 24],
            next: "walk4",
            frequency: 2
          },
          walk5: {
            frames: [26, 27, 28, 29],
            next: "walk5",
            frequency: 2
          }
        }
      };
      $.when(this.ready).then(function() {
        console.log("[Human] ready");
        this.spriteSheet = new SpriteSheet(this.data);
        this.animation = new BitmapAnimation(this.spriteSheet);
        this.stage.addChild(this.animation);
        return Ticker.addListener(this);
      });
    }

    Human.prototype.clear = function() {};

    Human.prototype.walk = function(i, j, i2, j2, k) {
      if (!this.visible) {
        this.appear(i, j, k);
      }
      this.walked = new $.Deferred();
      $.when(this.ready).then(function() {
        var dx, dy, p1, p2, turns;
        k = this.events.game.map.directionGet(i, j, i2, j2);
        p1 = this.events.ui.getPoint(i, j);
        p2 = this.events.ui.getPoint(i2, j2);
        this.animation.gotoAndPlay("walk" + k);
        turns = this.timeForAWalk / (1000 / Ticker.getMeasuredFPS());
        dx = p2.x - p1.x;
        dy = p2.y - p1.y;
        this.vx = Math.round(dx / turns);
        this.vy = Math.round(dy / turns);
        this.distance += this.walkDistance;
        return this.move = true;
      });
      return this.walked.promise();
    };

    Human.prototype.transfer = function(i, j, i2, j2, k) {
      var transfer;
      this.transferred = true;
      console.log("[Human] transfer", this.uid, i, j, i2, j2);
      transfer = new $.Deferred();
      $.when(this.walked).done(function() {
        var z;
        this.catchUpDistance = this.distance;
        this.catchUpVX = this.vx;
        this.catchUpVY = this.vy;
        z = this.walk(i, j, i2, j2, k);
        return $.when(z).done(function() {
          return transfer.resolveWith(this);
        });
      });
      return transfer.promise();
    };

    Human.prototype.appear = function(i, j, k) {
      return $.when(this.ready).then(function() {
        var p;
        if (!(k != null)) {
          k = 0;
        }
        p = this.events.ui.getPoint(i, j);
        this.animation.x = p.x;
        this.animation.y = p.y;
        this.animation.visible = true;
        this.visible = true;
        this.animation.gotoAndStop("stand" + k);
        return this.stage.update();
      });
    };

    Human.prototype.tick = function() {
      if (this.move) {
        this.animation.x += this.vx;
        this.animation.y += this.vy;
        this.distance -= Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        if (this.catchUpDistance > 0) {
          this.animation.x += this.catchUpVX;
          this.animation.y += this.catchUpVY;
          this.catchUpDistance -= Math.sqrt(this.catchUpVX * this.catchUpVX + this.catchUpVY * this.catchUpVY);
        }
        if (this.distance <= 0) {
          this.distance = 0;
          this.move = false;
          if (!this.transferred) {
            this.animation.visible = false;
            this.visible = false;
            return this.walked.resolveWith(this);
          } else {
            this.transferred = false;
            return this.walked.resolveWith(this);
          }
        }
      }
    };

    return Human;

  })();

  window.S.Human = Human;

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var People;

  People = (function() {

    function People(events, options) {
      var canvas2, i, _i;
      this.events = events;
      this.distance = options.distance;
      this.time = options.time + 5;
      canvas2 = document.getElementById('animations');
      this.stage = new Stage(canvas2);
      this.buffer = [];
      this.moving = {};
      this.allHumans = [];
      this.images = ['/img/traggerSprite.png'];
      for (i = _i = 0; _i < 3; i = ++_i) {
        this.create();
      }
      Ticker.addListener(this);
    }

    People.prototype.create = function() {
      var h;
      h = new S.Human(this.events, this.images[0], this.stage, this.distance, this.time);
      this.buffer.push(h);
      return this.allHumans.push(h);
    };

    People.prototype.transfer = function(h, i, j, i2, j2, k) {
      var self;
      self = this;
      return $.when(h.transfer(i, j, i2, j2, k)).done(function() {
        return self.clear.call(self, h);
      });
    };

    People.prototype.walkItHuman = function(i, j, i2, j2, k) {
      var h, self;
      if (this.buffer.length > 0) {
        h = this.buffer.pop();
      } else {
        h = this.create();
        h = this.buffer.pop();
      }
      self = this;
      return $.when(h.walk(i, j, i2, j2, k)).done(function() {
        return self.clear.call(self, h);
      });
    };

    People.prototype.clear = function(h) {
      h.clear();
      this.buffer.push(h);
      return this.onTheMove--;
    };

    People.prototype.walk = function(i, j, k) {
      var i2, j2, _ref;
      this.onTheMove++;
      _ref = this.events.game.map.directionModificators(i, j, k), i2 = _ref[0], j2 = _ref[1];
      return this.walkItHuman(i, j, i2, j2, k);
    };

    People.prototype.tick = function() {
      return this.stage.update();
    };

    return People;

  })();

  window.S.People = People;

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var BoardDrawer, Drawer, OffSignals, Renderer, SignalsDrawer,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Drawer = (function() {

    Drawer.prototype.margin = 150;

    Drawer.prototype.size = 45;

    Drawer.prototype.div = 60;

    function Drawer(minRow, maxRow) {
      this.minRow = minRow;
      this.maxRow = maxRow;
      this.horIncrement = Math.ceil(Math.sqrt(3) * this.size / 2);
      this.verIncrement = Math.ceil(3 * this.size / 2);
      this.diffRows = this.maxRow - this.minRow;
      this.distance = 2 * this.horIncrement;
      this.width = this.margin + (this.maxRow - 1) * this.distance + this.horIncrement;
      this.height = this.margin + this.diffRows * 2 * this.verIncrement + this.size;
      this.ticksX = [];
      this.ticksY = [];
      this.offsetX = [];
      this.offsetY = [];
      this.scrollX = 0;
      this.scrollY = 0;
      this.setupOffsets();
      this.setupTicks();
      this.viewportHeight = 0;
      this.viewportWidth = 0;
      this.directionModUpper = [[-1, -1], [0, -1], [1, 0], [1, 1], [0, 1], [-1, 0], [0, 0]];
      this.directionModLower = [[0, -1], [1, -1], [1, 0], [0, 1], [-1, 1], [-1, 0], [0, 0]];
      this.invisibleTerrain = {};
      this.canvasDimensions = {};
      this.canvasDimensions.x = $('canvas').first().outerWidth();
      /*
              2*(@margin-@horIncrement) +
              @maxRow * @distance + @margin
      */

      this.canvasDimensions.y = $('canvas').first().outerHeight();
      /*
              (@margin+@size) +
              (@diffRows * 2 + 1) * @verIncrement + @margin
      */

    }

    Drawer.prototype.setupOffsets = function() {
      this.offsetX = [-this.horIncrement, this.horIncrement, 2 * this.horIncrement, this.horIncrement, -this.horIncrement, -2 * this.horIncrement, 0];
      return this.offsetY = [-this.verIncrement, -this.verIncrement, 0, this.verIncrement, this.verIncrement, 0, 0];
    };

    Drawer.prototype.setupTicks = function() {
      var i, _i;
      for (i = _i = 0; _i <= 5; i = ++_i) {
        this.ticksX[i] = this.offsetX[i] / this.div;
        this.ticksY[i] = this.offsetY[i] / this.div;
      }
      return true;
    };

    Drawer.prototype.modifyCoords = function(x, y, dir) {
      var mod;
      if (y < this.diffRows || (y === this.diffRows && dir < 3)) {
        mod = this.directionModUpper[dir];
      } else if (y > this.diffRows || (y === this.diffRows && dir >= 3)) {
        mod = this.directionModLower[dir];
      }
      return [x + mod[0], y + mod[1]];
    };

    Drawer.prototype.setViewport = function(width, height) {
      this.viewportHeight = height;
      return this.viewportWidth = width;
    };

    Drawer.prototype.setScroll = function(x, y) {
      this.scrollX = x;
      return this.scrollY = y;
    };

    Drawer.prototype.setSize = function(size) {
      return this.size = size;
    };

    Drawer.prototype.setMargin = function(margin) {
      return this.margin = margin;
    };

    Drawer.prototype.getPoint = function(x, y) {
      var offset;
      offset = this.margin + Math.abs(this.diffRows - y) * this.horIncrement;
      return new Point(offset + 2 * x * this.horIncrement, this.margin + y * this.verIncrement);
    };

    Drawer.prototype.getDestination = function(point, direction) {
      return new Point(point.x + this.offsetX[direction], point.y + this.offsetY[direction]);
    };

    Drawer.prototype.getCoords = function(point) {
      var offset, x, y;
      y = (point.y - this.margin) / this.verIncrement;
      offset = this.margin + Math.abs(this.diffRows - y) * this.horIncrement;
      x = (point.x - offset) / (2 * this.horIncrement);
      return new Point(Math.round(x), Math.round(y));
    };

    Drawer.prototype.getTicks = function(direction) {
      var p;
      return p = new Point(this.ticksX[direction], this.ticksY[direction]);
    };

    Drawer.prototype.getDistance = function(x, y) {
      return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    };

    Drawer.prototype.contains = function(list, elem) {
      var e, _i, _len;
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        e = list[_i];
        if (_.isEqual(e, elem)) {
          return true;
        }
      }
      return false;
    };

    Drawer.prototype.without = function(list, elem) {
      var e, i, _i, _ref;
      for (i = _i = 0, _ref = list.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        e = list[i];
        if (_.isEqual(e, elem)) {
          return list.splice(0, i).concat(list.splice(i + 1));
        }
      }
      return list;
    };

    Drawer.prototype.union = function(list1, list2) {
      var elem, _i, _len;
      for (_i = 0, _len = list2.length; _i < _len; _i++) {
        elem = list2[_i];
        if (!this.contains(list1, elem)) {
          list1.push(elem);
        }
      }
      return list1;
    };

    Drawer.prototype.difference = function(list1, list2) {
      var elem, _i, _len;
      for (_i = 0, _len = list2.length; _i < _len; _i++) {
        elem = list2[_i];
        list1 = this.without(list1, elem);
      }
      return list1;
    };

    return Drawer;

  })();

  BoardDrawer = (function(_super) {

    __extends(BoardDrawer, _super);

    function BoardDrawer(bitmapsST, stages, minRow, maxRow, players, myPlayer) {
      this.bitmapsST = bitmapsST;
      this.stages = stages;
      this.players = players;
      this.myPlayer = myPlayer;
      BoardDrawer.__super__.constructor.call(this, minRow, maxRow);
      this.gridST = this.stages[0];
      this.fogST = this.stages[1];
      this.ownershipST = this.stages[2];
      this.resourcesST = this.stages[3];
      this.platformsST = this.stages[4];
      this.channelsST = this.stages[5];
      this.colors = ["#274E7D", "#900020", "#FFA000", "#B80049", "#00A550", "#9999FF", "#367588", "#FFFFFF"];
      this.visibility = [];
      this.ownership = [];
      this.roads = [];
      this.elements = {};
      this.owner = {};
      this.fog = {};
      this.bitmaps = [];
      this.shapes = [];
      this.setShapes();
      this.invisibleTerrain = this.fogST;
      this.fogON = true;
    }

    BoardDrawer.prototype.setShapes = function() {
      var drawChannel, drawFog, drawGrid,
        _this = this;
      drawFog = function() {
        var fog, g1;
        g1 = new Graphics();
        g1.beginFill("#000000").drawPolyStar(0, 0, _this.size * 1.008, 6, 0, 90);
        fog = new Shape(g1);
        fog.alpha = 0.6;
        fog.regX = _this.horIncrement;
        fog.regY = _this.size;
        _this.shapes[0] = fog;
        return _this.shapes[0].cache(-_this.horIncrement, -_this.size, _this.distance, _this.size * 2);
      };
      drawGrid = function() {
        var g2, grid;
        g2 = new Graphics();
        g2.setStrokeStyle(3).beginStroke("#616166").drawPolyStar(0, 0, _this.size, 6, 0, 90);
        grid = new Shape(g2);
        grid.regX = _this.horIncrement;
        grid.regY = _this.size;
        _this.shapes[1] = grid;
        return _this.shapes[1].cache(-_this.horIncrement, -_this.size, _this.distance, _this.size * 2);
      };
      drawChannel = function(point, direction) {
        var ch, destination, g;
        destination = _this.getDestination(point, direction);
        g = new Graphics();
        g.moveTo(point.x, point.y).setStrokeStyle(8, 1).beginStroke("#564334").lineTo(destination.x, destination.y).endStroke().moveTo(point.x, point.y).setStrokeStyle(5, 1).beginStroke("#CFB590").lineTo(destination.x, destination.y).endStroke().setStrokeStyle(2, 1).beginStroke("#564334").beginFill("#CFB590").drawCircle(point.x, point.y, 4).endStroke().setStrokeStyle(2, 1).beginStroke("#564334").beginFill("#CFB590").drawCircle(destination.x, destination.y, 4);
        ch = new Shape(g);
        return _this.shapes[2] = ch;
      };
      drawFog();
      drawGrid();
      return drawChannel(new Point(0, 0), 0);
    };

    BoardDrawer.prototype.addElement = function(x, y, e) {
      var _base, _base1, _ref, _ref1;
      if ((_ref = (_base = this.elements)[x]) == null) {
        _base[x] = [];
      }
      if ((_ref1 = (_base1 = this.elements[x])[y]) == null) {
        _base1[y] = [];
      }
      return this.elements[x][y].push(e);
    };

    BoardDrawer.prototype.addFog = function(x, y, e) {
      var _base, _ref;
      if ((_ref = (_base = this.fog)[x]) == null) {
        _base[x] = [];
      }
      return this.fog[x][y] = e;
    };

    BoardDrawer.prototype.addOwner = function(x, y, e) {
      var _base, _ref;
      if ((_ref = (_base = this.owner)[x]) == null) {
        _base[x] = [];
      }
      return this.owner[x][y] = e;
    };

    BoardDrawer.prototype.addPlayer = function(player) {
      return this.players.push(player);
    };

    BoardDrawer.prototype.updateAll = function() {
      var i, stage, _i, _results;
      _results = [];
      for (i = _i = 1; _i <= 5; i = ++_i) {
        stage = this.stages[i];
        stage.updateCache();
        _results.push(stage.update());
      }
      return _results;
    };

    BoardDrawer.prototype.clearData = function() {
      this.visibility = [];
      this.ownership = [];
      this.roads = [];
      this.elements = {};
      return this.fog = {};
    };

    BoardDrawer.prototype.buildPlatform = function(x, y, type) {
      var point;
      point = this.getPoint(x, y);
      this.addElement(x, y, this.drawPlatform(point, type));
      this.platformsST.updateCache();
      return this.platformsST.update();
    };

    BoardDrawer.prototype.buildChannel = function(x, y, direction, ownerid) {
      var point;
      point = this.getPoint(x, y);
      this.addElement(x, y, this.drawChannel(point, direction));
      if (this.fogON) {
        this.setVisibility([x, y], true, ownerid);
      }
      return this.updateAll();
    };

    BoardDrawer.prototype.captureOwnership = function(x, y, ownerid, status) {
      var point;
      point = this.getPoint(x, y);
      switch (status) {
        case 1:
          this.addOwner(x, y, this.drawOwnership(point, ownerid));
          if (ownerid === this.myPlayer.id) {
            if (!(this.contains(this.ownership, [x, y]))) {
              this.ownership.push([x, y]);
            }
          } else {
            this.ownership = this.without(this.ownership, [x, y]);
          }
          this.setVisibility([x, y], false, ownerid);
          break;
        case 2:
          if (ownerid !== this.myPlayer.id) {
            this.ownership = this.without(this.ownership, point);
          } else {
            this.setVisibility([x, y], false, ownerid);
          }
          this.owner[x][y].visible = false;
          this.owner[x][y] = null;
      }
      return this.updateAll();
    };

    BoardDrawer.prototype.changeOwnership = function(x, y, ownerid) {
      var point;
      point = this.getPoint(x, y);
      this.addOwner(x, y, this.drawOwnership(point, ownerid));
      if (this.fogON) {
        this.setVisibility([x, y], true, ownerid);
      }
      if (ownerid === this.myPlayer.id && !(this.contains(this.ownership, point))) {
        this.ownership.push([x, y]);
      }
      return this.updateAll();
    };

    BoardDrawer.prototype.drawFog = function(point) {
      var fog;
      fog = this.shapes[0].clone();
      fog.x = point.x;
      fog.y = point.y;
      this.fogST.addChild(fog);
      return fog;
    };

    BoardDrawer.prototype.drawGrid = function(point) {
      var border;
      border = this.shapes[1].clone();
      border.x = point.x;
      border.y = point.y;
      this.gridST.addChild(border);
      return border;
    };

    BoardDrawer.prototype.drawOwnership = function(point, ownerid) {
      var draw, owner,
        _this = this;
      draw = function(ownerid) {
        var g;
        g = new Graphics();
        g.setStrokeStyle(4).beginStroke(_this.colors[_.indexOf(_this.players, ownerid)]).drawPolyStar(0, 0, _this.size * 0.93, 6, 0, 90);
        return new Shape(g);
      };
      owner = draw(ownerid);
      if (this.fogON) {
        owner.visible = false;
      }
      owner.x = point.x;
      owner.y = point.y;
      this.ownershipST.addChild(owner);
      return owner;
    };

    BoardDrawer.prototype.drawPlatform = function(point, type) {
      var bitmap, draw,
        _this = this;
      draw = function(type) {
        var bitmap;
        switch (type) {
          case S.Types.Entities.Platforms.HQ:
            bitmap = _this.bitmapsST.getChildAt(2).clone();
            break;
          case S.Types.Entities.Platforms.Normal:
            bitmap = _this.bitmapsST.getChildAt(4).clone();
        }
        return bitmap;
      };
      bitmap = draw(type);
      if (this.fogON) {
        bitmap.visible = false;
      } else {
        bitmap.visible = true;
      }
      bitmap.x = point.x;
      bitmap.y = point.y;
      this.platformsST.addChild(bitmap);
      return bitmap;
    };

    BoardDrawer.prototype.drawResource = function(point, type) {
      var draw, resource,
        _this = this;
      draw = function(type) {
        var resource;
        switch (type) {
          case S.Types.Resources.Gold:
            resource = _this.bitmapsST.getChildAt(1).clone();
            resource.regX = 30;
            resource.regY = 35;
            break;
          case S.Types.Resources.Food:
            resource = _this.bitmapsST.getChildAt(0).clone();
            break;
          case S.Types.Resources.Resources:
            resource = _this.bitmapsST.getChildAt(3).clone();
        }
        return resource;
      };
      resource = draw(type);
      if (this.fogON) {
        resource.visible = false;
      } else {
        resource.visible = true;
      }
      resource.x = point.x;
      resource.y = point.y;
      this.resourcesST.addChild(resource);
      return resource;
    };

    BoardDrawer.prototype.drawChannel = function(point, direction) {
      var channel;
      channel = this.shapes[2].clone();
      channel.x = point.x;
      channel.y = point.y;
      channel.rotation = direction * 60;
      channel.alpha = 0.7;
      if (this.fogON) {
        channel.visible = false;
      } else {
        channel.visible = true;
      }
      this.channelsST.addChild(channel);
      return channel;
    };

    BoardDrawer.prototype.setFog = function(point, status) {
      var _ref;
      if (((_ref = this.fog[point[0]]) != null ? _ref[point[1]] : void 0) != null) {
        return this.fog[point[0]][point[1]].visible = status;
      }
    };

    BoardDrawer.prototype.setElements = function(point, status) {
      var elem, _i, _len, _ref, _ref1, _ref2;
      if (((_ref = this.elements[point[0]]) != null ? _ref[point[1]] : void 0) != null) {
        _ref1 = this.elements[point[0]][point[1]];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          elem = _ref1[_i];
          elem.visible = status;
        }
      }
      if (((_ref2 = this.owner[point[0]]) != null ? _ref2[point[1]] : void 0) != null) {
        return this.owner[point[0]][point[1]].visible = status;
      }
    };

    BoardDrawer.prototype.setVisibility = function(point, status, ownerid) {
      var array, i, p, tab, _i, _j, _k, _l, _len, _len1, _len2, _results;
      array = [];
      for (i = _i = 0; _i <= 6; i = ++_i) {
        array.push(this.modifyCoords(point[0], point[1], i));
      }
      console.log("ARRAY", array);
      if (ownerid === this.myPlayer.id) {
        for (_j = 0, _len = array.length; _j < _len; _j++) {
          p = array[_j];
          this.setFog(p, false);
          this.setElements(p, true);
        }
        this.visibility = this.union(this.visibility, array);
        if (!(this.contains(this.roads, point))) {
          return this.roads.push(point);
        }
      } else {
        if (status) {
          _results = [];
          for (_k = 0, _len1 = array.length; _k < _len1; _k++) {
            p = array[_k];
            if (this.contains(this.visibility, p)) {
              _results.push(this.setElements(p, true));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        } else {
          this.roads = this.without(this.roads, point);
          this.visibility = this.getVisibility(this.roads);
          this.setElements(point, true);
          console.log("[BOARD] Visbility", this.visibility);
          tab = this.difference(array, this.visibility);
          for (_l = 0, _len2 = tab.length; _l < _len2; _l++) {
            p = tab[_l];
            this.setFog(p, true);
          }
          return console.log("[BOARD] DIFF", tab);
        }
      }
    };

    BoardDrawer.prototype.getVisibility = function(ownership) {
      var array, i, point, visibility, _i, _j, _len;
      visibility = [];
      for (_i = 0, _len = ownership.length; _i < _len; _i++) {
        point = ownership[_i];
        array = [];
        for (i = _j = 0; _j <= 6; i = ++_j) {
          array.push(this.modifyCoords(point[0], point[1], i));
        }
        visibility = this.union(visibility, array);
      }
      return visibility;
    };

    BoardDrawer.prototype.setupHex = function(point, x, y, field) {
      if (this.fogON) {
        this.addFog(x, y, this.drawFog(point));
      }
      this.drawGrid(point);
      if (field.resource.behaviour != null) {
        this.addElement(x, y, this.drawResource(point, field.resource.type()));
      }
      this.setupPlatform(point, x, y, field);
      return this.setupChannels(point, x, y, field);
    };

    BoardDrawer.prototype.setupPlatform = function(point, x, y, field) {
      var ownerid;
      if (field.platform.type != null) {
        this.addElement(x, y, this.drawPlatform(point, field.platform.type()));
        ownerid = field.platform.state.owner.id;
        this.addOwner(x, y, this.drawOwnership(point, ownerid));
        if (ownerid === this.myPlayer.id) {
          if (!(this.contains(this.ownership, [x, y]))) {
            this.ownership.push([x, y]);
          }
          if (!(this.contains(this.roads, [x, y]))) {
            return this.roads.push([x, y]);
          }
        }
      }
    };

    BoardDrawer.prototype.setupChannels = function(point, x, y, field) {
      var channel, k, ownerIDs, _i;
      ownerIDs = [];
      for (k = _i = 0; _i <= 5; k = ++_i) {
        channel = field.channels[k];
        if (channel != null) {
          this.addElement(x, y, this.drawChannel(point, k));
          ownerIDs = this.union(ownerIDs, [channel.state.owner.id]);
        }
      }
      if (_.keys(field.channels).length >= 2 && ownerIDs.length === 1) {
        this.addOwner(x, y, this.drawOwnership(point, ownerIDs[0]));
        if (!(this.contains(this.ownership, [x, y])) && this.contains(ownerIDs, this.myPlayer.id)) {
          this.ownership.push([x, y]);
        }
      }
      if (_.keys(field.channels).length >= 1 && !(this.contains(this.roads, [x, y]))) {
        if (this.contains(ownerIDs, this.myPlayer.id)) {
          return this.roads.push([x, y]);
        }
      }
    };

    BoardDrawer.prototype.setupBoard = function(boardState) {
      var i, j, point, _i, _j, _ref, _ref1;
      for (j = _i = 0, _ref = 2 * this.diffRows + 1; 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {
        for (i = _j = 0, _ref1 = this.maxRow - Math.abs(this.diffRows - j); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          point = this.getPoint(i, j);
          this.setupHex(point, i, j, boardState.getField(i, j));
        }
      }
      if (this.fogON) {
        this.toogleFog(true);
      }
      return this.toogleCache(true);
    };

    BoardDrawer.prototype.toogleFog = function(status) {
      var point, _i, _len, _ref, _results;
      if (status) {
        this.visibility = this.getVisibility(this.roads);
        _ref = this.visibility;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          point = _ref[_i];
          this.setFog(point, false);
          _results.push(this.setElements(point, true));
        }
        return _results;
      }
    };

    BoardDrawer.prototype.toogleCache = function(status) {
      var i, stage, _i;
      for (i = _i = 0; _i <= 5; i = ++_i) {
        stage = this.stages[i];
        if (status) {
          stage.cache(0, 0, this.width + 5, this.height + 5);
        } else {
          stage.uncache();
        }
      }
      return true;
    };

    return BoardDrawer;

  })(Drawer);

  OffSignals = (function() {

    OffSignals.prototype.signalRadius = 7;

    OffSignals.prototype.signalCount = 150;

    function OffSignals(stage, players) {
      this.stage = stage;
      this.players = players;
      this.stage.snapToPixelEnabled = true;
      this.colors = ["#274E7D", "#900020", "#FFA000", "#B80049", "#00A550", "#9999FF", "#367588", "#FFFFFF"];
    }

    OffSignals.prototype.getSignal = function() {
      var signal;
      signal = this.stage.getChildAt(0);
      if (this.stage.removeChildAt(0)) {
        return signal;
      } else {
        this.addNewSignals();
        return this.getSignal();
      }
    };

    OffSignals.prototype.setupSignalTable = function() {
      var i, _i, _ref;
      for (i = _i = 0, _ref = this.signalCount; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.drawSignal();
      }
      return this.toogleCache(true);
    };

    OffSignals.prototype.addNewSignals = function() {
      this.signalCount = 2 * this.signalCount;
      return this.setupSignalTable();
    };

    OffSignals.prototype.drawSignal = function() {
      var g, shape;
      g = new Graphics();
      g.setStrokeStyle(2).beginStroke("#0F4DA8").beginFill("#437DD4").drawCircle(0, 0, this.signalRadius);
      shape = new Shape(g);
      shape.snapToPixel = true;
      shape.visible = false;
      shape.isSignal = true;
      shape.alpha = 0.8;
      return this.stage.addChild(shape);
    };

    OffSignals.prototype.toogleCache = function(status) {
      var i, length, shape, _i;
      length = this.stage.getNumChildren() - 1;
      for (i = _i = 0; 0 <= length ? _i <= length : _i >= length; i = 0 <= length ? ++_i : --_i) {
        shape = this.stage.getChildAt(i);
        if (status) {
          shape.cache(-this.signalRadius - 1, -this.signalRadius - 1, (this.signalRadius + 1) * 2, (this.signalRadius + 1) * 2);
        } else {
          shape.uncache();
        }
      }
      return true;
    };

    return OffSignals;

  })();

  SignalsDrawer = (function(_super) {

    __extends(SignalsDrawer, _super);

    SignalsDrawer.prototype.signalRadius = 8;

    SignalsDrawer.prototype.signalCount = 50;

    function SignalsDrawer(eventBus, stage, offStage, minRow, maxRow, boardDR, players) {
      this.eventBus = eventBus;
      this.stage = stage;
      this.offStage = offStage;
      this.boardDR = boardDR;
      this.players = players;
      SignalsDrawer.__super__.constructor.call(this, minRow, maxRow);
      this.offSignals = new OffSignals(this.offStage, this.players);
      window.p = this.people = new S.People(this.eventBus, {
        distance: 80,
        time: S.Properties.channel.delay
      });
      Ticker.addListener(this);
    }

    SignalsDrawer.prototype.setupFPS = function() {
      this.fpsLabel = new Text("-- fps", "bold 18px Arial", "#FFF");
      this.stage.addChild(this.fpsLabel);
      this.fpsLabel.x = 10;
      this.fpsLabel.y = 20;
      return this.fpsLabel.isSignal = false;
    };

    SignalsDrawer.prototype.setupOffSignals = function() {
      return this.offSignals.setupSignalTable();
    };

    SignalsDrawer.prototype.drawSignal = function(point, dir) {
      var signal;
      signal = this.getSignal();
      if (signal === null) {
        signal = this.offSignals.getSignal();
        this.stage.addChild(signal);
      }
      signal.x = point.x;
      signal.y = point.y;
      signal.tickSizeX = this.offsetX[dir] / Ticker.getMeasuredFPS();
      signal.tickSizeY = this.offsetY[dir] / Ticker.getMeasuredFPS();
      signal.visible = true;
      return signal.k = 0;
    };

    SignalsDrawer.prototype.drawWorker = function(x, y, direction) {
      if (this.contains(this.boardDR.visibility, [x, y])) {
        return this.people.walk(x, y, direction);
      }
    };

    SignalsDrawer.prototype.getSignal = function() {
      var sig, _i, _len, _ref;
      _ref = this.stage.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sig = _ref[_i];
        if (sig.isSignal && !sig.visible) {
          return sig;
        }
      }
      return null;
    };

    SignalsDrawer.prototype.createSignal = function(x, y, direction) {
      var point;
      if (this.contains(this.boardDR.visibility, [x, y])) {
        point = this.getPoint(x, y);
        this.drawSignal(point, direction);
        return this.stage.update();
      }
    };

    SignalsDrawer.prototype.tick = function() {
      var signal, _i, _len, _ref;
      _ref = this.stage.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        signal = _ref[_i];
        if (signal.isSignal && signal.isVisible) {
          signal.visible = true;
          if (this.getDistance(signal.k * signal.tickSizeX, signal.k * signal.tickSizeY) >= this.distance) {
            signal.visible = false;
          } else {
            signal.x += signal.tickSizeX;
            signal.y += signal.tickSizeY;
            signal.k += 1;
          }
        }
      }
      this.fpsLabel.text = Math.round(Ticker.getMeasuredFPS()) + " fps";
      return this.stage.update();
    };

    return SignalsDrawer;

  })(Drawer);

  Renderer = (function() {

    function Renderer(eventBus, minRow, maxRow, players, myPlayer) {
      var canvasBitmaps, canvasChannels, canvasFog, canvasGrid, canvasOff, canvasOwnership, canvasPlatforms, canvasResources, canvasSignals, imagesLoaded,
        _this = this;
      canvasOwnership = document.getElementById("ownership");
      canvasResources = document.getElementById("resources");
      canvasPlatforms = document.getElementById("platforms");
      canvasGrid = document.getElementById("grid");
      canvasChannels = document.getElementById("channels");
      canvasFog = document.getElementById("fog");
      canvasSignals = document.getElementById("signals");
      canvasOff = document.getElementById("off");
      canvasBitmaps = document.getElementById("bitmaps");
      this.bitmaps = ["/img/Food.png", "/img/Gold.png", "/img/hq.png", "/img/iron.png", "/img/platform.png", "/img/road.png"];
      this.boardLoaded = $.Deferred();
      this.loading = $.Deferred();
      if (canvasOwnership != null) {
        this.ownershipST = new Stage(canvasOwnership);
      }
      if (canvasResources != null) {
        this.resourcesST = new Stage(canvasResources);
      }
      if (canvasPlatforms != null) {
        this.platformsST = new Stage(canvasPlatforms);
        this.bitmapsST = new Stage(canvasBitmaps);
      }
      if (canvasGrid != null) {
        this.gridST = new Stage(canvasGrid);
      }
      if (canvasChannels != null) {
        this.channelsST = new Stage(canvasChannels);
      }
      if (canvasFog != null) {
        this.fogST = new Stage(canvasFog);
      }
      if (canvasSignals != null) {
        this.signalsST = new Stage(canvasSignals);
        this.offST = new Stage(canvasOff);
      }
      this.stages = [this.gridST, this.fogST, this.ownershipST, this.resourcesST, this.platformsST, this.channelsST, this.signalsST];
      imagesLoaded = $.Deferred();
      this.loadImages(imagesLoaded);
      $.when(imagesLoaded.promise()).done(function() {
        var boardStages;
        console.log('[Renderer] all Images have been loaded');
        boardStages = [_this.gridST, _this.fogST, _this.ownershipST, _this.resourcesST, _this.platformsST, _this.channelsST];
        _this.boardDR = new BoardDrawer(_this.bitmapsST, boardStages, minRow, maxRow, players, myPlayer);
        _this.signalsDR = new SignalsDrawer(eventBus, _this.signalsST, _this.offST, minRow, maxRow, _this.boardDR, players);
        return _this.boardLoaded.resolve();
      });
    }

    Renderer.prototype.loadImages = function(dfd) {
      var bitmap, compare, count, loadBitmap, setImg, _i, _len, _ref, _results,
        _this = this;
      count = 0;
      compare = function(a, b) {
        if (a.image.src >= b.image.src) {
          return 1;
        } else if (a.image.src < b.image.src) {
          return -1;
        }
      };
      setImg = function(event) {
        var bitmap;
        bitmap = new Bitmap(event.target);
        bitmap.visible = false;
        bitmap.regX = 35;
        bitmap.regY = 40;
        _this.bitmapsST.addChild(bitmap);
        count++;
        if (count === _this.bitmaps.length) {
          _this.bitmapsST.sortChildren(compare);
          console.log('[Renderer] image loaded event', count);
          return dfd.resolve();
        }
      };
      loadBitmap = function(bitmap) {
        var img;
        img = new Image;
        img.src = bitmap;
        return img.onload = setImg;
      };
      _ref = this.bitmaps;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        bitmap = _ref[_i];
        _results.push(loadBitmap(bitmap));
      }
      return _results;
    };

    Renderer.prototype.addPlayer = function(player) {
      return this.boardDR.addPlayer(player);
    };

    Renderer.prototype.clearAll = function() {
      var stage, _i, _len, _ref;
      _ref = this.stages;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        stage = _ref[_i];
        stage.removeAllChildren();
      }
      return true;
    };

    Renderer.prototype.updateAll = function() {
      var stage, _i, _len, _ref;
      _ref = this.stages;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        stage = _ref[_i];
        stage.update();
      }
      return true;
    };

    Renderer.prototype.switchFog = function(status) {
      return this.boardDR.fogON = status;
    };

    Renderer.prototype.moveSignal = function(x, y, direction) {
      return this.signalsDR.createSignal(x, y, direction);
    };

    Renderer.prototype.buildChannel = function(x, y, direction, channel) {
      return this.boardDR.buildChannel(x, y, direction, channel.state.owner.id);
    };

    Renderer.prototype.buildPlatform = function(x, y, platform) {
      return this.boardDR.buildPlatform(x, y, platform.type());
    };

    Renderer.prototype.captureOwnership = function(x, y, ownerid, status) {
      return this.boardDR.captureOwnership(x, y, ownerid, status);
    };

    Renderer.prototype.changeOwnership = function(x, y, ownerid) {
      return this.boardDR.changeOwnership(x, y, ownerid);
    };

    Renderer.prototype.setupBoard = function(boardState) {
      this.clearAll();
      this.signalsDR.setupFPS();
      this.boardDR.clearData();
      this.signalsDR.setupOffSignals();
      this.boardDR.setupBoard(boardState);
      Ticker.useRAF = true;
      Ticker.setFPS(60);
      return this.updateAll();
    };

    return Renderer;

  })();

  window.S.Drawer = Drawer;

  window.S.Renderer = Renderer;

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var MenuDisplayHelper;

  MenuDisplayHelper = (function() {

    function MenuDisplayHelper(events, type, menu, i, j, x, y) {
      this.events = events;
      this.type = type;
      this.menu = menu;
      this.i = i;
      this.j = j;
      this.x = x;
      this.y = y;
      this.data = {};
      this.build = {
        'price': {
          start: function() {
            var resources;
            console.log("[MDH] start - price");
            resources = this.data;
            console.log(resources);
            this.data = _.map(resources, function(v, k) {
              return {
                name: k,
                value: v
              };
            });
            console.log(this.data);
            this.template = Handlebars.templates.costinfo;
            return this.html = $(this.template({
              resources: this.data
            }));
          },
          show: function() {
            var height, p, width;
            console.log("[MDH] show - price");
            this.html.appendTo('#canvasWrapper .scrollIt');
            width = this.html.width();
            height = this.html.height();
            p = this.menu.button.localToGlobal(0, 0);
            x = p.x + 80;
            y = p.y - height / 2;
            return this.html.css({
              position: 'absolute',
              top: y,
              left: x,
              'z-index': 500
            });
          },
          hide: function() {
            console.log("[MDH] - hide - price");
            this.html.hide();
            return this.html.remove();
          }
        },
        'platforminfo': {
          start: function() {
            var field, platformSt, res, resource;
            field = this.events.getField(this.i, this.j);
            platformSt = field.platform.state;
            this.data.platformName = S.Types.Entities.Names[platformSt.type];
            this.data.resources = [];
            if ((field.resource.state != null) && (field.resource.state.type != null) && platformSt.type !== S.Types.Entities.Platforms.HQ) {
              resource = field.resource.state;
              res = {
                size: Math.floor(resource.life),
                extraction: Math.round((resource.extraction * 1000) / resource.delay),
                name: S.Types.Resources.Names[resource.type - 6]
              };
              this.data.resources.push(res);
            } else if (platformSt.type === S.Types.Entities.Platforms.HQ) {
              res = {
                size: "Infinity",
                extraction: Math.round((platformSt.extraction * 1000) / platformSt.delay),
                name: "Food"
              };
              this.data.resources.push(res);
              res = {
                size: "Infinity",
                extraction: Math.round((platformSt.extraction * 1000) / platformSt.delay),
                name: "Gold"
              };
              this.data.resources.push(res);
            }
            this.data.life = platformSt.life;
            this.data.space = platformSt.signals.length;
            this.data.maxSpace = platformSt.capacity;
            this.data.platform = this.data;
            this.template = Handlebars.templates.platforminfo;
            return this.html = $('<div/>');
          },
          show: function() {
            var height, p, scrollX, scrollY, width;
            this.html.remove();
            this.html = $(this.template(this.data));
            scrollX = this.events.ui.scrollX;
            scrollY = this.events.ui.scrollY;
            this.html.hide();
            this.html.appendTo('#canvasWrapper .scrollIt');
            width = this.html.width();
            height = this.html.height();
            p = this.menu.button.parent.localToGlobal(this.x, this.y);
            x = p.x - width - 60;
            y = p.y - height / 2;
            this.html.css({
              position: 'absolute',
              top: y,
              left: x,
              'z-index': 500
            });
            return this.html.show();
          },
          hide: function() {
            this.html.hide();
            return this.html.remove();
          }
        }
      };
    }

    MenuDisplayHelper.prototype.start = function() {
      if ((this.build[this.type] != null) && (this.build[this.type].start != null)) {
        return this.build[this.type].start.call(this);
      }
    };

    MenuDisplayHelper.prototype.setData = function(data) {
      return this.data = data;
    };

    MenuDisplayHelper.prototype.show = function() {
      if (this.build[this.type].show != null) {
        return this.build[this.type].show.call(this);
      }
    };

    MenuDisplayHelper.prototype.hide = function() {
      if (this.build[this.type].hide != null) {
        return this.build[this.type].hide.call(this);
      }
    };

    return MenuDisplayHelper;

  })();

  window.S.MenuDisplayHelper = MenuDisplayHelper;

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var MapHelper,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  MapHelper = (function(_super) {

    __extends(MapHelper, _super);

    function MapHelper(events, minRow, maxRow) {
      this.events = events;
      this.minRow = minRow;
      this.maxRow = maxRow;
      this.close = __bind(this.close, this);

      this.clean = __bind(this.clean, this);

      this.cancel = __bind(this.cancel, this);

      this.accept = __bind(this.accept, this);

      this.clickField = __bind(this.clickField, this);

      this.parseAndPrepareEvent = __bind(this.parseAndPrepareEvent, this);

      this.help = __bind(this.help, this);

      this.canvas = document.getElementById("helpers");
      this.stage = new Stage(this.canvas);
      this.stage.mouseEventsEnabled = true;
      this.stage.enableMouseOver(20);
      MapHelper.__super__.constructor.call(this, this.minRow, this.maxRow);
      this.cwidth = this.canvasDimensions.x;
      this.cheight = this.canvasDimensions.y;
      this.colours = {
        positive: "rgba(0,255,0,0.4)",
        negative: "rgba(255,0,0,0.4)",
        over: "rgba(255,255,255,0.3)",
        stroke: "rgba(0,0,0,0.8)",
        fill: "rgba(255,255,255,0.2)"
      };
      _.extend(this, Backbone.Events);
      this.$overlay = $(this.canvas).css({
        background: "rgba(0,0,0,0.7)"
      });
      this.$overlay.hide();
      this.fieldsObjs = {};
      $(this).bind("contextmenu", function(e) {
        return e.preventDefault();
      });
      $(this.canvas).bind("contextmenu", function(e) {
        return e.preventDefault();
      });
      this.helpers = {
        routing: {
          show: function(io, jo) {
            var angle, color, field, i, j, k, p, text, textContainer, tr, z, _i, _ref;
            field = this.currentMenu.obj;
            for (z = _i = 0; _i < 6; z = ++_i) {
              if (__indexOf.call(this.currentMenu.validFields, z) >= 0) {
                _ref = this.getIJ(io, jo, z), i = _ref[0], j = _ref[1];
                p = this.getPoint(i, j);
                this.state = field.platform.state.routing;
                if (this.state[z]["in"]) {
                  color = this.colours.positive;
                } else {
                  color = this.colours.negative;
                }
                k = (5 - z) % 6;
                angle = 60 * (z - 2);
                tr = this.drawHalfHex(i, j, k, color, this.colours.stroke);
                tr.z = z;
                this.fieldsObjs[i + ":" + j + ":" + k] = tr;
                this.stage.addChild(tr);
                if (this.state[z].out) {
                  color = this.colours.positive;
                } else {
                  color = this.colours.negative;
                }
                tr = this.drawHalfHex(i, j, k + 3, color, this.colours.stroke);
                tr.z = z;
                this.fieldsObjs[i + ":" + j + ":" + (k + 3)] = tr;
                this.stage.addChild(tr);
                textContainer = new Container();
                this.stage.addChild(textContainer);
                textContainer.x = p.x;
                textContainer.y = p.y;
                textContainer.rotation = angle;
                text = new Text("in", "bold 13px 'Cabin', Helvetica,Arial,sans-serif", '#fff');
                text.textAlign = 'center';
                text.textBaseline = 'middle';
                text.x = -15;
                text.rotation = -angle;
                textContainer.addChild(text);
                text = new Text("out", "bold 13px 'Cabin', Helvetica,Arial,sans-serif", '#fff');
                text.textAlign = 'center';
                text.textBaseline = 'middle';
                text.x = 15;
                text.rotation = -angle;
                textContainer.addChild(text);
              }
            }
            this.acceptShow.call(this, io, jo);
            return this.cancelShow.call(this, io, jo);
          },
          over: function(i, j, k) {
            var color, field, kIn, tr, z;
            field = this.currentMenu.obj;
            tr = this.fieldsObjs[i + ":" + j + ":" + k];
            z = tr.z;
            kIn = (5 - z) % 6;
            if (k === kIn) {
              if (this.state[z]["in"]) {
                color = this.colours.negative;
              } else {
                color = this.colours.positive;
              }
            } else {
              if (this.state[z].out) {
                color = this.colours.negative;
              } else {
                color = this.colours.positive;
              }
            }
            return this.drawHalfHex(i, j, k, color, this.colours.stroke, tr);
          },
          out: function(i, j, k) {
            var color, field, kIn, tr, z;
            field = this.currentMenu.obj;
            tr = this.fieldsObjs[i + ":" + j + ":" + k];
            z = tr.z;
            kIn = (5 - z) % 6;
            if (k === kIn) {
              if (this.state[z]["in"]) {
                color = this.colours.positive;
              } else {
                color = this.colours.negative;
              }
            } else {
              if (this.state[z].out) {
                color = this.colours.positive;
              } else {
                color = this.colours.negative;
              }
            }
            return this.drawHalfHex(i, j, k, color, this.colours.stroke, tr);
          },
          click: function(i, j, k) {
            var color, kIn, tr, z;
            tr = this.fieldsObjs[i + ":" + j + ":" + k];
            z = tr.z;
            kIn = (5 - z) % 6;
            if (k === kIn) {
              if (this.state[z]["in"]) {
                this.state[z]["in"] = false;
                color = this.colours.negative;
              } else {
                this.state[z]["in"] = true;
                color = this.colours.positive;
              }
            } else {
              if (this.state[z].out) {
                this.state[z].out = false;
                color = this.colours.negative;
              } else {
                color = this.colours.positive;
                this.state[z].out = true;
              }
            }
            return this.drawHalfHex(i, j, k, color, this.colours.stroke, tr);
          },
          generateArguments: function(io, jo, i, j, k) {
            var routing;
            routing = this.state;
            this.state = null;
            return [this.currentMenu.obj, routing];
          }
        },
        build: {
          platform: {
            show: function(io, jo) {
              return this.accept(io, jo, 0);
            },
            generateArguments: function(io, jo, i, j, k) {
              return [io, jo, S.Types.Entities.Platforms.Normal, void 0];
            }
          },
          channel: {
            show: function(io, jo) {
              var h, i, j, z, _i, _ref;
              for (z = _i = 0; _i < 6; z = ++_i) {
                if (__indexOf.call(this.currentMenu.validFields, z) >= 0) {
                  _ref = this.getIJ(io, jo, z), i = _ref[0], j = _ref[1];
                  h = this.drawHex(i, j, 0, this.colours.fill, this.colours.stroke);
                  this.fieldsObjs[i + ":" + j] = h;
                  this.stage.addChild(h);
                }
              }
              return this.cancelShow.call(this, io, jo);
            },
            generateArguments: function(io, jo, i, j, k) {
              var field;
              field = this.currentMenu.obj;
              k = this.getK(io, jo, i, j);
              return [field.xy[0], field.xy[1], k, void 0];
            },
            over: function(i, j, k) {
              var color, h;
              color = "rgba(255,255,255,0.8)";
              h = this.fieldsObjs[i + ":" + j];
              return this.drawHex(i, j, 0, "#fff", color, h);
            },
            out: function(i, j, k) {
              var color, h;
              color = "rgba(0,0,0,0.9)";
              h = this.fieldsObjs[i + ":" + j];
              return this.drawHex(i, j, 0, this.colours.fill, color, h);
            },
            click: function(i, j, k) {
              return this.accept(i, j, k);
            }
          }
        }
      };
      this.on('all', this.parseAndPrepareEvent);
      Ticker.addListener(this);
    }

    MapHelper.prototype.isLegal = function(i, j, ci, cj) {};

    MapHelper.prototype.getK = function(i, j, ci, cj) {
      return this.events.game.map.directionGet(i, j, ci, cj);
    };

    MapHelper.prototype.getIJ = function(i, j, k) {
      var mi, mj, _ref;
      _ref = this.events.game.map.directionModificators(i, j, k), mi = _ref[0], mj = _ref[1];
      return [mi, mj];
    };

    MapHelper.prototype.acceptShow = function(io, jo) {
      var c, p, text, tr;
      c = new Container();
      tr = this.drawHex(io + 3, jo, 0, this.colours.positive, this.colours.stroke);
      tr.onClick = this.accept;
      tr.onMouseOver = null;
      tr.onMouseOut = null;
      p = this.getPoint(io + 3, jo);
      text = new Text('Execute', "bold 13px 'Cabin', Helvetica,Arial,sans-serif", '#fff');
      text.textAlign = 'center';
      text.textBaseline = 'middle';
      text.y = p.y;
      text.x = p.x;
      text.onClick = this.cancel;
      c.addChild(tr);
      c.addChild(text);
      return this.stage.addChild(c);
    };

    MapHelper.prototype.cancelShow = function(io, jo) {
      var c, p, text, tr;
      c = new Container();
      tr = this.drawHex(io + 4, jo, 0, this.colours.negative, this.colours.stroke);
      tr.onClick = this.cancel;
      tr.onMouseOver = null;
      tr.onMouseOut = null;
      p = this.getPoint(io + 4, jo);
      text = new Text("Cancel", "bold 13px 'Cabin', Helvetica,Arial,sans-serif", '#fff');
      text.textAlign = 'center';
      text.textBaseline = 'middle';
      text.y = p.y;
      text.x = p.x;
      text.onClick = this.cancel;
      c.addChild(tr);
      c.addChild(text);
      return this.stage.addChild(c);
    };

    MapHelper.prototype.drawHex = function(i, j, k, fill, stroke, h) {
      var g, hex, p,
        _this = this;
      if (h != null) {
        hex = h;
      } else {
        hex = new Shape();
      }
      g = hex.graphics;
      g.clear();
      p = this.getPoint(i, j);
      g.beginStroke(stroke).beginFill(fill).drawPolyStar(0, 0, this.size, 6, 0, 90);
      hex.x = p.x;
      hex.y = p.y;
      hex.cache(-this.horIncrement, -this.size, this.distance, this.size * 2);
      hex.onMouseOver = function() {
        return _this.overField(i, j, k);
      };
      hex.onMouseOut = function() {
        return _this.outField(i, j, k);
      };
      hex.onClick = function() {
        return _this.clickField(i, j, k);
      };
      return hex;
    };

    MapHelper.prototype.drawTriangle = function(i, j, k, fill, stroke, tr) {
      var g, p, triangle, x1, x2, y1, y2,
        _this = this;
      if (tr != null) {
        triangle = tr;
      } else {
        triangle = new Shape();
      }
      g = triangle.graphics;
      g.clear();
      p = this.getPoint(i, j);
      x1 = this.size * Math.sin(k * Math.PI / 3);
      y1 = this.size * Math.cos(k * Math.PI / 3);
      x2 = this.size * Math.sin((k + 1) * Math.PI / 3);
      y2 = this.size * Math.cos((k + 1) * Math.PI / 3);
      g.beginStroke(stroke).beginFill(fill).lineTo(x1, y1).lineTo(x2, y2).lineTo(0, 0).closePath().endFill().endStroke();
      triangle.cache(-this.horIncrement, -this.size, this.distance, this.size * 2);
      triangle.x = p.x;
      triangle.y = p.y;
      triangle.onMouseOver = function() {
        return _this.overField(i, j, k);
      };
      triangle.onMouseOut = function() {
        return _this.outField(i, j, k);
      };
      return triangle;
    };

    MapHelper.prototype.drawHalfHex = function(i, j, k, fill, stroke, hh) {
      var g, halfHex, p, x1, x2, x3, x4, y1, y2, y3, y4,
        _this = this;
      if (hh != null) {
        halfHex = hh;
      } else {
        halfHex = new Shape();
      }
      g = halfHex.graphics;
      g.clear();
      p = this.getPoint(i, j);
      x1 = this.size * Math.sin(k * Math.PI / 3);
      y1 = this.size * Math.cos(k * Math.PI / 3);
      x2 = this.size * Math.sin((k + 1) * Math.PI / 3);
      y2 = this.size * Math.cos((k + 1) * Math.PI / 3);
      x3 = this.size * Math.sin((k + 2) * Math.PI / 3);
      y3 = this.size * Math.cos((k + 2) * Math.PI / 3);
      x4 = this.size * Math.sin((k + 3) * Math.PI / 3);
      y4 = this.size * Math.cos((k + 3) * Math.PI / 3);
      g.beginStroke(stroke).beginFill(fill).lineTo(x1, y1).lineTo(x2, y2).lineTo(x3, y3).lineTo(x4, y4).lineTo(0, 0).closePath().endFill().endStroke();
      halfHex.cache(-this.horIncrement, -this.size, this.distance, this.size * 2);
      halfHex.x = p.x;
      halfHex.y = p.y;
      halfHex.onMouseOver = function() {
        return _this.overField(i, j, k);
      };
      halfHex.onMouseOut = function() {
        return _this.outField(i, j, k);
      };
      halfHex.onClick = function() {
        return _this.clickField(i, j, k);
      };
      return halfHex;
    };

    MapHelper.prototype.showOverlay = function() {
      this.$overlay.show();
      return $(this.canvas).css({
        'z-index': 20
      });
    };

    MapHelper.prototype.hideOverlay = function() {
      this.$overlay.hide();
      return $(this.canvas).css({
        'z-index': 7
      });
    };

    MapHelper.prototype.overField = function(i, j, k) {
      if (this.currentHelper != null) {
        return this.currentHelper.over.call(this, i, j, k);
      }
    };

    MapHelper.prototype.outField = function(i, j, k) {
      if (this.currentHelper != null) {
        return this.currentHelper.out.call(this, i, j, k);
      }
    };

    MapHelper.prototype.highlightField = function(i, j) {
      if (this.currentHelper != null) {
        return this.currentHelper.highlight.call(this, i, j);
      }
    };

    MapHelper.prototype.help = function(event, caller) {
      this.update = true;
      return this.parseAndPrepareEvent(event, caller);
    };

    MapHelper.prototype.parseAndPrepareEvent = function(event, caller) {
      var obj, path;
      console.log("map:helper:" + event);
      path = event.split(':');
      obj = _.reduce(path, function(memo, p) {
        if (memo[p] != null) {
          return memo[p];
        } else if (memo.show != null) {
          return memo;
        } else {
          return null;
        }
      }, this.helpers);
      if (obj != null) {
        this.currentDeferr = new $.Deferred();
        this.currentHelper = obj;
        this.i = caller.obj.xy[0];
        this.j = caller.obj.xy[1];
        this.currentMenu = caller;
        this.currentEvent = event;
        this.showOverlay();
        this.currentHelper.show.call(this, this.i, this.j);
        return this.currentDeferr.promise();
      }
    };

    MapHelper.prototype.clickField = function(i, j, k) {
      if (this.currentHelper != null) {
        return this.currentHelper.click.call(this, i, j, k);
      }
    };

    MapHelper.prototype.accept = function(i, j, k) {
      var args;
      args = this.currentHelper.generateArguments.call(this, this.i, this.j, i, j, k);
      args = [this.currentEvent].concat(args);
      this.currentDeferr.resolveWith(this.currentMenu, args);
      this.clean();
      return this.close();
    };

    MapHelper.prototype.cancel = function() {
      this.currentDeferr.rejectWith(this.currentMenu, [this.currentEvent]);
      this.clean();
      return this.close();
    };

    MapHelper.prototype.clean = function() {
      var hex, _i, _len, _ref;
      _ref = this.fieldsObjs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hex = _ref[_i];
        hex.clear();
        hex.onClick = null;
        hex.onMouseOver = null;
        hex.onMouseOut = null;
      }
      this.currentMenu = null;
      this.currentEvent = null;
      this.currentHelper = null;
      this.stage.removeAllChildren();
      return this.stage.addChild(this.overlay);
    };

    MapHelper.prototype.close = function() {
      this.hideOverlay();
      this.update = false;
      return this.stage.update();
    };

    MapHelper.prototype.tick = function() {
      if (this.update) {
        return this.stage.update();
      }
    };

    return MapHelper;

  })(S.Drawer);

  window.S.MapHelper = MapHelper;

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var RadialMenu,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  RadialMenu = (function() {

    RadialMenu.prototype.event = "";

    RadialMenu.prototype.desc = "";

    RadialMenu.prototype.text = "";

    RadialMenu.prototype.expanded = false;

    RadialMenu.prototype.expandedChildren = false;

    RadialMenu.prototype.visible = false;

    function RadialMenu(engine, canvas, x, y, text, desc, root, obj) {
      var _ref, _ref1,
        _this = this;
      this.engine = engine;
      this.canvas = canvas;
      this.x = x;
      this.y = y;
      this.text = text;
      this.desc = desc;
      this.root = root;
      this.obj = obj;
      this.tick = __bind(this.tick, this);

      this["in"] = __bind(this["in"], this);

      this.click = __bind(this.click, this);

      this.rotateAnimate = __bind(this.rotateAnimate, this);

      this.rotate = __bind(this.rotate, this);

      this.hideText = __bind(this.hideText, this);

      this.showText = __bind(this.showText, this);

      this.undisplayText = __bind(this.undisplayText, this);

      this.displayText = __bind(this.displayText, this);

      this.expandAnimate = __bind(this.expandAnimate, this);

      this.collapseAnimate = __bind(this.collapseAnimate, this);

      this.hideAnimate = __bind(this.hideAnimate, this);

      this.showAnimate = __bind(this.showAnimate, this);

      this.collapse = __bind(this.collapse, this);

      this.hideChildren = __bind(this.hideChildren, this);

      this.collapseChildren = __bind(this.collapseChildren, this);

      this.expand = __bind(this.expand, this);

      this.hitTest = __bind(this.hitTest, this);

      this.hide = __bind(this.hide, this);

      this.show = __bind(this.show, this);

      this.restoreFlags = __bind(this.restoreFlags, this);

      this.draw = __bind(this.draw, this);

      this.drawIt = __bind(this.drawIt, this);

      this.action = __bind(this.action, this);

      this.menuId = _.uniqueId();
      _.extend(this, Backbone.Events);
      $(this.canvas).bind("contextmenu", function(e) {
        return e.preventDefault();
      });
      this.positive_action = 'Yes';
      this.negative_action = 'No';
      this.actionHelper = null;
      this.displayHelper = null;
      /*
          Get the context and stage we will be drawing to. Only for the root it will be the actuall context, for every other element it will get
          overwritten by root's context and stage.
      */

      this.stage = new Stage(this.canvas);
      this.stage.autoclear = false;
      this.container = new Container();
      this.parent = null;
      this.x_o = 0;
      this.y_o = 0;
      if ((_ref = this.x) == null) {
        this.x = this.x_o;
      }
      if ((_ref1 = this.y) == null) {
        this.y = this.y_o;
      }
      /*
          Distances from the origin in different states.
      */

      this.length = 0;
      this.length_base = 70;
      this.expand_length = this.length_base;
      this.compact_length = 50;
      this.expandTime = 500;
      this.compactTime = 500;
      this.hideTime = 200;
      this.showTime = 50;
      this.priority = 100;
      this.fadedInOpacity = 1;
      this.fadedOutOpacity = 0.3;
      this.opacity = 1;
      this.validFields = [];
      this.visible = false;
      this.descDisplayed = false;
      this.expanded = false;
      this.expanding = false;
      this.collapsing = false;
      this.showing = false;
      this.hiding = false;
      this.rotating = false;
      this.drawn = false;
      this.radius = 10;
      this.alpha = Math.PI / 3;
      this.beta = -(Math.PI * 7 / 6);
      this.children = [];
      this.initializeDOM = _.once(function() {
        /*
              This is a title displayed next to the menu item. It is hidden by
              default and shown only when menu item is in visibile state
        */
        _this.$title = new Text(_this.text, "bold 13px 'Cabin', Helvetica,Arial,sans-serif", "#FFF");
        _this.$title.visible = false;
        _this.$actionTitle = new Text(_this.positive_action, "bold 13px 'Cabin', Helvetica,Arial,sans-serif", "#FFF");
        _this.$actionTitle.visible = false;
        _this.$title.onClick = _this.click;
        _this.$actionTitle.onClick = _this.action;
        _this.$desc = $("<div/>");
        _this.$desc.html(_this.desc);
        _this.$desc.addClass('radial-menu-desc');
        _this.$desc.addClass('hyphenate');
        return _this.$desc.appendTo('body');
      });
    }

    RadialMenu.prototype.changeDOM = function() {
      this.$title.text = this.text;
      this.$actionTitle.text = this.positive_action;
      return this.$desc.html(this.desc);
    };

    RadialMenu.prototype.addChild = function(menu) {
      menu.priority = this.priority - 1;
      menu.stage = this.stage;
      menu.parent = this;
      menu.beta = menu.beta - this.children.length * this.alpha;
      menu.childIndex = this.children.length;
      menu.obj = this.obj;
      menu.actionHelper = this.actionHelper;
      return this.children.push(menu);
    };

    RadialMenu.prototype.setObj = function(obj) {
      var child, _i, _len, _ref, _results;
      this.obj = obj;
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        _results.push(child.setObj(obj));
      }
      return _results;
    };

    RadialMenu.prototype.setValidFields = function(array) {
      return this.validFields = array;
    };

    RadialMenu.prototype.setRoot = function(root) {
      var child, _i, _len, _ref;
      this.rootElement = root;
      _ref = this.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        child.setRoot(root);
      }
      return null;
    };

    RadialMenu.prototype.setPrice = function(price) {
      return this.price = price;
    };

    RadialMenu.prototype.setDisplayHelper = function(displayHelper) {
      return this.displayHelper = displayHelper;
    };

    RadialMenu.prototype.setActionHelper = function(actionHelper) {
      var child, _i, _len, _ref, _results;
      this.actionHelper = actionHelper;
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        _results.push(child.setActionHelper(actionHelper));
      }
      return _results;
    };

    RadialMenu.prototype.action = function() {
      var helperPromise;
      if (this.actionHelper != null) {
        helperPromise = this.actionHelper.help(this.event, this);
        $.when(helperPromise).done(function() {
          return this.executeAction.apply(this, arguments);
        });
      } else {
        this.executeAction.call(this, this.event);
      }
      return this.rootElement.hide(this.rootElement.destroy);
    };

    RadialMenu.prototype.executeAction = function() {
      console.log(arguments);
      return this.engine.trigger.apply(this.engine, arguments);
    };

    RadialMenu.prototype.actionArgs = function() {};

    RadialMenu.prototype.setEvent = function(ev) {
      return this.event = ev;
    };

    RadialMenu.prototype.setPositiveAction = function(positive_action) {
      this.positive_action = positive_action;
    };

    RadialMenu.prototype.setNegativeAction = function(negative_action) {
      this.negative_action = negative_action;
    };

    RadialMenu.prototype.computeP = function(length, beta) {
      var x, y;
      if (length == null) {
        length = this.length;
      }
      if (beta == null) {
        beta = this.beta;
      }
      x = length * Math.sin(beta);
      y = length * Math.cos(beta);
      return [x, y];
    };

    RadialMenu.prototype.drawIt = function() {
      var c, _i, _len, _ref, _results;
      this.draw();
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(c.drawIt());
      }
      return _results;
    };

    RadialMenu.prototype.draw = function() {
      var P, c, _i, _len, _ref;
      if (this.drawn) {
        return false;
      }
      this.drawn = true;
      this.button = new Shape();
      this.button = this.children.length < 1 ? this.drawButtonBlue(this.button) : this.drawButtonOrange(this.button);
      if (!this.root) {
        this.button.onClick = this.click;
      }
      this.circle = new Shape();
      this.circle.visible = false;
      this.circle.graphics.setStrokeStyle(2).beginStroke("rgba(0,0,0," + (this.fadedOutOpacity / 4) + ")").drawCircle(this.x_o, this.y_o, this.expand_length);
      this.circleC = new Shape();
      this.circleC.visible = false;
      this.circleC.graphics.setStrokeStyle(2).beginStroke("rgba(0,0,0," + (this.fadedOutOpacity / 4) + ")").drawCircle(this.x_o, this.y_o, this.compact_length);
      this.actionButton = new Shape();
      this.actionButton.onClick = this.action;
      if (this.children.length < 1) {
        this.actionButton = this.drawButtonOrange(this.actionButton);
        this.actionButton.y += 40;
      }
      P = this.button.localToGlobal(this.x_o, this.y_o);
      this.initializeDOM();
      this.$title.x = 15;
      this.$title.y = 5;
      this.$actionTitle.x = 15;
      this.$actionTitle.y = 45;
      if (this.root) {
        this.container.addChild(this.$title);
        this.container.addChild(this.$actionTitle);
        this.stage.addChild(this.circleC);
        this.stage.addChild(this.circle);
        this.stage.addChild(this.button);
        this.stage.addChild(this.container);
      } else {
        this.container.addChild(this.$title);
        this.container.addChild(this.$actionTitle);
        this.parent.container.addChild(this.circleC);
        this.parent.container.addChild(this.circle);
        this.parent.container.addChild(this.button);
        this.parent.container.addChild(this.actionButton);
        this.parent.container.addChild(this.container);
      }
      this.button.visible = false;
      this.actionButton.visible = false;
      _ref = this.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        c.draw();
      }
      this.button.cache(this.x_o - this.radius, this.y_o - this.radius, this.radius * 2, this.radius * 2);
      this.actionButton.cache(this.x_o - this.radius, this.y_o - this.radius, this.radius * 2, this.radius * 2);
      return Ticker.addListener(this, false);
    };

    RadialMenu.prototype.destroy = function() {
      var child, _i, _len, _ref;
      _ref = this.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        child.destroy();
      }
      if (this.displayHelper) {
        this.displayHelper.hide();
      }
      this.hideText();
      this.$desc.remove();
      this.button.visible = false;
      this.container.visible = false;
      $(this.canvas).unbind("contextmenu", function(e) {
        return e.preventDefault();
      });
      return Ticker.removeListener(this);
    };

    RadialMenu.prototype.drawButtonOrange = function(button) {
      button.graphics.beginRadialGradientFill(["#F38630", "#FA6900", "#222"], [0, 0.7, 1], this.x_o, this.y_o, 0, this.x_o, this.y_o, this.radius).drawCircle(this.x_o, this.y_o, this.radius);
      return button;
    };

    RadialMenu.prototype.drawButtonBlue = function(button) {
      button.graphics.beginRadialGradientFill(["#A7DBD8", "#69D2E7", "#222"], [0, 0.7, 1], this.x_o, this.y_o, 0, this.x_o, this.y_o, this.radius).drawCircle(this.x_o, this.y_o, this.radius);
      return button;
    };

    RadialMenu.prototype.restoreFlags = function() {
      this.expanded = false;
      this.expandedChildren = false;
      return this.visible = false;
    };

    RadialMenu.prototype.show = function() {
      var x, y, _ref;
      if (!this.drawn) {
        this.draw();
      }
      this.showing = true;
      this.hiding = false;
      _ref = this.computeP(this.length_base), x = _ref[0], y = _ref[1];
      if (!this.root && this.x !== x && this.y !== y) {
        this.steps = this.showTime / Ticker.getInterval();
        this.stepX = (x - this.x) / this.steps;
        this.stepY = (y - this.y) / this.steps;
        this.stepOpacity = (1 - this.opacity) / this.steps;
        this.length = this.length_base;
      } else {
        this.steps = 0;
        this.stepX = 0;
        this.stepY = 0;
        this.stepOpacity = 0;
      }
      this.$title.visible = true;
      if (!this.root) {
        return this.button.visible = true;
      }
    };

    RadialMenu.prototype.hide = function(fn) {
      var x, y;
      this.showing = false;
      this.hiding = true;
      x = 0;
      y = 0;
      if (fn != null) {
        this.hideFn = fn;
      } else {
        this.hideFn = function() {};
      }
      if (!this.root && this.x !== x && this.y !== y) {
        this.steps = this.showTime / Ticker.getInterval();
        this.stepX = this.x / this.steps;
        this.stepY = this.y / this.steps;
        this.stepOpacity = (-this.opacity) / this.steps;
      } else {
        this.steps = 0;
        this.stepX = 0;
        this.stepY = 0;
        this.stepOpacity = 0;
      }
      this.hideChildren();
      this.circle.visible = false;
      return this.circleC.visible = false;
    };

    RadialMenu.prototype.hitTest = function(x, y, recursive) {
      var child, global, l, rsq, sq;
      sq = function(a) {
        return a * a;
      };
      if (this.circle.visible) {
        l = this.expand_length;
      } else if (this.circleC.visible) {
        l = this.compact_length;
      }
      rsq = l + 10;
      global = this.button.parent.localToGlobal(this.x, this.y);
      if (rsq > 0) {
        if (rsq > Math.sqrt(sq(x - global.x) + sq(y - global.y))) {
          return true;
        } else if (recursive) {
          return _.any((function() {
            var _i, _len, _ref, _results;
            _ref = this.children;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              child = _ref[_i];
              _results.push(child.hitTest(x, y));
            }
            return _results;
          }).call(this));
        }
      }
      return false;
    };

    RadialMenu.prototype.expand = function(expandChildren) {
      var c, x, y, _i, _len, _ref, _ref1;
      if (!this.visible) {
        this.show();
      }
      if (this.children.length > 0) {
        this.circle.visible = true;
      }
      this.expanding = true;
      this.collapsing = false;
      _ref = this.computeP(this.expand_length), x = _ref[0], y = _ref[1];
      if (!this.root && this.x !== x && this.y !== y) {
        this.steps = this.showTime / Ticker.getInterval();
        this.stepX = (x - this.x) / this.steps;
        this.stepY = (y - this.y) / this.steps;
        this.stepOpacity = (this.fadedInOpacity - this.opacity) / this.steps;
        this.length = this.expand_length;
      } else {
        this.steps = 0;
        this.stepX = 0;
        this.stepY = 0;
        this.stepOpacity = 0;
      }
      if (expandChildren) {
        _ref1 = this.children;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          c = _ref1[_i];
          c.show();
        }
        return this.expanded = true;
      }
    };

    RadialMenu.prototype.collapseChildren = function(child) {
      var c, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        this.undisplayText(c);
      }
      _ref1 = this.children;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        c = _ref1[_j];
        if (c !== child) {
          c.collapse();
        }
      }
      this.circle.visible = true;
      if (this.children.length > 1) {
        return this.circleC.visible = true;
      }
    };

    RadialMenu.prototype.hideChildren = function() {
      var c, _i, _j, _len, _len1, _ref, _ref1;
      this.expanded = false;
      _ref = this.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        this.undisplayText(c);
      }
      _ref1 = this.children;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        c = _ref1[_j];
        c.hide();
      }
      this.circle.visible = false;
      return this.circleC.visible = false;
    };

    RadialMenu.prototype.collapse = function() {
      var x, y, _ref;
      this.collapsing = true;
      this.expanding = false;
      _ref = this.computeP(this.compact_length), x = _ref[0], y = _ref[1];
      if (!this.root && this.x !== x && this.y !== y) {
        this.steps = this.showTime / Ticker.getInterval();
        this.stepX = (this.x - x) / this.steps;
        this.stepY = (this.y - y) / this.steps;
        this.stepOpacity = (this.fadedOutOpacity - this.opacity) / this.steps;
        this.length = this.compact_length;
      } else {
        this.steps = 0;
        this.stepX = 0;
        this.stepY = 0;
        this.stepOpacity = 0;
      }
      this.hideChildren();
      this.circle.visible = false;
      return this.circleC.visible = false;
    };

    RadialMenu.prototype.showAnimate = function() {
      if (this.steps <= 0) {
        this.showing = false;
        this.visible = true;
        this.$title.visible = true;
        if (this.displayHelper) {
          return this.displayHelper.show();
        }
      } else {
        this.steps--;
        this.x += this.stepX;
        this.y += this.stepY;
        return this.opacity += this.stepOpacity;
      }
    };

    RadialMenu.prototype.hideAnimate = function() {
      if (this.steps <= 0) {
        this.hiding = false;
        this.visible = false;
        this.$title.visible = false;
        if (this.root) {
          this.hideText();
          this.button.visible = false;
          this.container.visible = false;
          return this.hideFn();
        }
      } else {
        this.steps--;
        this.x -= this.stepX;
        this.y -= this.stepY;
        return this.opacity += this.stepOpacity;
      }
    };

    RadialMenu.prototype.collapseAnimate = function() {
      if (this.steps <= 0) {
        this.collapsing = false;
        return this.expanded = false;
      } else {
        this.x -= this.stepX;
        this.y -= this.stepY;
        this.opacity += this.stepOpacity;
        return this.steps--;
      }
    };

    RadialMenu.prototype.expandAnimate = function() {
      if (this.steps <= 0) {
        return this.expanding = false;
      } else {
        this.x += this.stepX;
        this.y += this.stepY;
        this.opacity += this.stepOpacity;
        return this.steps--;
      }
    };

    RadialMenu.prototype.displayText = function(child) {
      var angle, rangePi, rotation;
      if (child.descDisplayed) {
        return;
      }
      rangePi = function(angle) {
        while (angle < 0) {
          angle += Math.PI * 2;
        }
        return angle % (Math.PI * 2);
      };
      angle = rangePi(child.beta);
      if (angle > (Math.PI / 2) - 0.2 && angle < (Math.PI / 2) + 0.2) {
        return child.rotate(0, child.showText);
      } else if (angle > 0 && angle < Math.PI / 2) {
        rotation = Math.PI / 2 - angle;
        return child.rotate(rotation, child.showText);
      } else if (angle < Math.PI + 0.2 && angle > Math.PI / 2) {
        rotation = angle - Math.PI / 2;
        return child.rotate(-rotation, child.showText);
      }
    };

    RadialMenu.prototype.undisplayText = function(child) {
      if (!child.descDisplayed) {
        return;
      }
      child.beta = child.gamma;
      return child.hideText();
    };

    RadialMenu.prototype.showText = function() {
      var global;
      global = this.parent.container.localToGlobal(this.x, this.y);
      this.$desc.css({
        top: global.y - 10,
        left: global.x + this.$title.getMeasuredWidth() + 25
      });
      this.$desc.slideDown(200);
      this.descDisplayed = true;
      this.actionButton.visible = true;
      return this.$actionTitle.visible = true;
    };

    RadialMenu.prototype.hideText = function() {
      this.$desc.hide();
      this.descDisplayed = false;
      this.actionButton.visible = false;
      return this.$actionTitle.visible = false;
    };

    RadialMenu.prototype.rotate = function(angle, fn, full) {
      var child, _i, _len, _ref;
      this.gamma = this.beta;
      if (!(fn != null)) {
        fn = function() {};
      }
      this.rotationFn = fn;
      this.rotateSteps = this.showTime / Ticker.getInterval();
      this.rotateStep = angle / this.rotateSteps;
      this.rotateStepXY = full;
      if (full) {
        _ref = this.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          child.rotate(angle, null, true);
        }
      }
      return this.rotating = true;
    };

    RadialMenu.prototype.rotateAnimate = function() {
      var x, y, _ref;
      if (this.rotateSteps <= 0) {
        this.rotateStepXY = 0;
        this.rotationFn();
        this.rotationFn = function() {};
        return this.rotating = false;
      } else {
        this.beta += this.rotateStep;
        if (this.rotateStepXY) {
          _ref = this.computeP(this.length), x = _ref[0], y = _ref[1];
          if (this.root) {
            this.x += x;
            this.y += y;
          } else {
            this.x = x;
            this.y = y;
          }
        }
        return this.rotateSteps--;
      }
    };

    RadialMenu.prototype.click = function(show) {
      if (!this.expanded) {
        this.expand(true);
        if (!this.root) {
          this.parent.collapseChildren(this);
          if (this.children.length < 1) {
            if (this.desc.length === 0) {
              return this.action();
            } else if (!this.descDisplayed) {
              return this.parent.displayText(this);
            } else {
              return this.parent.undisplayText(this);
            }
          }
        } else if (this.displayHelper) {
          return this.displayHelper.show();
        }
      } else {
        if (this.children.length < 1) {
          if (this.desc.length === 0) {
            this.action();
          } else if (!this.descDisplayed) {
            this.parent.displayText(this);
          } else {
            this.parent.undisplayText(this);
            this.parent.expand(true);
          }
        }
        return this.hideChildren();
      }
    };

    RadialMenu.prototype["in"] = function(x, y) {
      return this.button.hitTest(x, y);
    };

    RadialMenu.prototype.tick = function(time) {
      this.animating = this.rotating || this.showing || this.hiding || this.expanding || this.collapsing;
      if ((!this.drawn || !this.animating) && !this.root) {
        return false;
      }
      if (this.rotating) {
        this.rotateAnimate();
      }
      if (this.showing) {
        this.showAnimate();
      }
      if (this.hiding) {
        this.hideAnimate();
      }
      if (this.expanding) {
        this.expandAnimate();
      }
      if (this.collapsing) {
        this.collapseAnimate();
      }
      /*
          Apply new coordinates computated by animating functions
      */

      this.circle.x = this.x;
      this.circle.y = this.y;
      this.circleC.x = this.x;
      this.circleC.y = this.y;
      this.button.x = this.x;
      this.button.y = this.y;
      this.actionButton.x = this.x;
      this.actionButton.y = this.y + 40;
      this.button.alpha = this.opacity;
      this.$title.alpha = this.opacity;
      if (!this.root) {
        this.container.x = this.x;
        this.container.y = this.y;
      } else {
        this.container.x = this.x;
        this.container.y = this.y;
      }
      /*
          We do not want to update the stage too many times so we call this
          only from the root element of the menu
      */

      if (this.root) {
        return this.stage.update();
      }
    };

    return RadialMenu;

  })();

  window.S.RadialMenu = RadialMenu;

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var UI,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  UI = (function(_super) {

    __extends(UI, _super);

    function UI(events, minRow, maxRow) {
      this.events = events;
      this.minRow = minRow;
      this.maxRow = maxRow;
      this.handleClickOnField = __bind(this.handleClickOnField, this);

      this.handleClick = __bind(this.handleClick, this);

      this.buildMenu = __bind(this.buildMenu, this);

      this.scroll = __bind(this.scroll, this);

      this.resizeViewport = __bind(this.resizeViewport, this);

      this.start = __bind(this.start, this);

      this.canvas = document.getElementById("UI");
      this.stage = new Stage(this.canvas);
      this.stage.autoclear = false;
      UI.__super__.constructor.call(this, this.minRow, this.maxRow);
      this.canvasContainer = $("#canvasWrapper").first();
      this.setScroller();
      this.scrollX = 0;
      this.scrollY = 0;
      this.bubble = [];
      this.resourcesTemplate = Handlebars.templates.resources;
      this.resizeViewport();
    }

    UI.prototype.start = function() {
      var scrollerDown, scrollerMove, scrollerUp, viewportHeight, viewportWidth,
        _this = this;
      viewportHeight = window.innerHeight;
      viewportWidth = window.innerWidth - 200;
      this.mousedown = false;
      this.events.trigger('resize', viewportWidth, viewportHeight);
      scrollerDown = function(e) {
        _this.scroller.doTouchStart([
          {
            pageX: e.pageX,
            pageY: e.pageY
          }
        ], e.timeStamp);
        return _this.mousedown = true;
      };
      scrollerMove = function(e) {
        if (!_this.mousedown) {
          return;
        }
        _this.scroller.doTouchMove([
          {
            pageX: e.pageX,
            pageY: e.pageY
          }
        ], e.timeStamp);
        return _this.mousedown = true;
      };
      scrollerUp = function(e) {
        if (!_this.mousedown) {
          return;
        }
        _this.scroller.doTouchEnd(e.timeStamp);
        return _this.mousedown = false;
      };
      this.canvasContainer.get()[0].addEventListener("mousedown", scrollerDown, false);
      document.addEventListener("mousemove", scrollerMove, false);
      document.addEventListener("mouseup", scrollerUp, false);
      this.curMenu = null;
      this.menuHelper = new S.MapHelper(this.events, this.minRow, this.maxRow);
      this.showResources();
      $(this.canvas).bind("contextmenu", this.handleClick);
      $(window).bind("contextmenu", function(e) {
        return e.preventDefault();
      });
      $(window).resize(this.resizeViewport);
      return Ticker.addListener(this);
    };

    UI.prototype.getLoadingStage = function(loading) {
      this.loading = loading;
    };

    UI.prototype.setLoadingStage = function(loading) {
      this.loading = loading;
    };

    UI.prototype.gameOver = function() {
      return $('<div id="gameover"><h1>You Lost</h1></div>').appendTo('#canvasWrapper');
    };

    UI.prototype.gameTied = function() {
      return $('<div id="gameover"><h1>Game Tied</h1></div>').appendTo('#canvasWrapper');
    };

    UI.prototype.gameWon = function() {
      return $('<div id="gameover"><h1>You Won</h1></div>').appendTo('#canvasWrapper');
    };

    UI.prototype.showTextBubble = function(text, x, y, options) {
      var a, b, bubble, config, g, i, r, tInv, _ref;
      config = {
        vy: 100,
        vx: 0,
        t: 1000,
        color: [255, 255, 255, 1]
      };
      _.extend(config, options);
      i = -1;
      _.each(this.bubble, function(b, k) {
        if (b.animate === false) {
          i = k;
          return {};
        }
      });
      if (i < 0) {
        bubble = new Text();
        bubble.textAlign = 'center';
        bubble.baseline = '';
        bubble.font = "bold 13px 'Cabin', Helvetica,Arial,sans-serif";
        bubble.color = config.color;
        this.stage.addChild(bubble);
        this.bubble.push(bubble);
        i = this.bubble.length - 1;
      }
      bubble = this.bubble[i];
      tInv = config.t / Ticker.getInterval();
      bubble.alpha = 1;
      _ref = config.color, r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];
      bubble.color = "rgba(" + r + "," + g + "," + b + "," + a + ")";
      bubble.c = config.color;
      bubble.text = text;
      bubble.x = x;
      bubble.y = y;
      bubble.valpha = 1 / tInv;
      bubble.vx = config.vx / tInv;
      bubble.vy = config.vy / tInv;
      bubble.t = config.t;
      bubble.visible = true;
      bubble.animate = true;
      return this.stage.update();
    };

    UI.prototype.tick = function() {
      var a, b, bubble, g, interval, r, update, _i, _len, _ref, _ref1;
      interval = Ticker.getInterval();
      update = false;
      _ref = this.bubble;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        bubble = _ref[_i];
        if (bubble.animate === true) {
          if (bubble.t > 0) {
            _ref1 = bubble.c, r = _ref1[0], g = _ref1[1], b = _ref1[2], a = _ref1[3];
            a -= bubble.valpha;
            a = Math.max(a, 0);
            bubble.color = "rgba(" + r + "," + g + "," + b + "," + a + ")";
            bubble.c = [r, g, b, a];
            bubble.x -= bubble.vx;
            bubble.y -= bubble.vy;
            bubble.t -= interval;
          } else {
            bubble.animate = false;
            bubble.visible = false;
          }
          update = true;
        }
      }
      if (update) {
        return this.stage.update();
      }
    };

    UI.prototype.initializeMenus = function() {
      return null;
    };

    UI.prototype.resizeViewport = function() {
      var $chat, maxChatWidth, viewportHeight, viewportWidth;
      $chat = $('#chat');
      this.viewportHeight = viewportHeight = window.innerHeight;
      this.viewportWidth = viewportWidth = window.innerWidth - $chat.outerWidth();
      maxChatWidth = window.innerWidth - this.canvasDimensions.x - 18;
      console.log(maxChatWidth, 300, window.innerWidth, this.canvasDimensions.x, 18);
      if (maxChatWidth > 300) {
        $chat.width(maxChatWidth);
        this.viewportWidth = viewportWidth = window.innerWidth - $chat.outerWidth();
        this.canvasContainer.css({
          height: viewportHeight,
          width: viewportWidth,
          overflow: 'hidden'
        }).first();
      } else {
        $chat.width(300);
        this.viewportWidth = viewportWidth = window.innerWidth - $chat.outerWidth();
        this.canvasContainer.css({
          height: viewportHeight,
          width: viewportWidth,
          overflow: 'hidden'
        }).first();
      }
      this.scroller.setDimensions(viewportWidth, viewportHeight, this.canvasDimensions.x, this.canvasDimensions.y);
      return this.events.trigger('resize', viewportWidth, viewportHeight);
    };

    UI.prototype.setScroller = function() {
      var viewportHeight, viewportWidth;
      viewportHeight = window.innerHeight;
      viewportWidth = window.innerWidth - 200;
      this.canvasContainer.css({
        height: viewportHeight,
        width: viewportWidth,
        overflow: 'hidden'
      }).first();
      this.scroller = new Scroller(this.scroll, {
        locking: false,
        bouncing: true,
        animating: true
      });
      return this.scroller.setDimensions(viewportWidth, viewportHeight, this.canvasDimensions.x, this.canvasDimensions.y);
    };

    UI.prototype.scroll = function(x, y) {
      this.scrollX = x;
      this.scrollY = y;
      this.events.trigger('scroll', x, y);
      return this.canvasContainer.find('canvas, .scrollIt').not('.noScroll').each(function(i, el) {
        var $el, left, top;
        $el = $(el);
        top = -y;
        left = -x;
        return $el.css({
          top: top,
          left: left
        });
      });
    };

    UI.prototype.showResources = function(amount, type) {
      var html, name, resources, value;
      resources = this.events.myPlayer.resources;
      if (!(this.$html != null)) {
        resources = _.map(resources, function(v, k) {
          return {
            name: k,
            value: v
          };
        });
        html = this.resourcesTemplate({
          resources: resources
        });
        return this.$html = $(html).appendTo('#canvasWrapper');
      } else {
        name = S.Types.Resources.Names[type - 6];
        value = resources[name];
        console.log("[UI] resources", amount, type, value, name);
        return this.$html.find(".res-" + name).html(name + " : " + value);
      }
    };

    UI.prototype.createMenu = function(i, j) {
      var displayHelper, eventsStructure, listOfOwnership, menu, menuDesc, menuInfo, menuSpDisplay, menuStructure, menuValidFields, mine, obj, p, subMenu, submenuName, submenuNames, _i, _len, _ref;
      p = this.getPoint(i, j);
      menuInfo = this.events.getMenu(i, j);
      obj = this.events.getField(i, j);
      listOfOwnership = this.events.renderer.boardDR.roads;
      mine = _.find(listOfOwnership, function(v) {
        var i2, j2;
        i2 = v[0], j2 = v[1];
        return i2 === i && j2 === j;
      });
      if (!(menuInfo != null) || !(mine != null) || ((((_ref = this.events.renderer.boardDR.owner[i]) != null ? _ref[j] : void 0) != null) && !this.contains(this.events.renderer.boardDR.ownership, [i, j]))) {
        return;
      }
      console.log("[UI]", i, j, menuInfo, obj);
      menuStructure = menuInfo[0], menuValidFields = menuInfo[1];
      menuDesc = _.find(menuStructure, function(menu) {
        return menu.search("/:*") === 0;
      });
      menuDesc = menuDesc != null ? (menuStructure = _.without(menuStructure, menuDesc), menuDesc.substring(2)) : null;
      menuSpDisplay = _.find(menuStructure, function(menu) {
        return menu.search("/!*") === 0;
      });
      menuSpDisplay = menuSpDisplay != null ? (menuStructure = _.without(menuStructure, menuSpDisplay), menuSpDisplay.substring(2)) : null;
      menu = new S.RadialMenu(this.events, this.stage.canvas, p.x, p.y, "", "", true, obj);
      eventsStructure = S.Types.Events;
      submenuNames = this.getPrefixes(menuStructure);
      for (_i = 0, _len = submenuNames.length; _i < _len; _i++) {
        submenuName = submenuNames[_i];
        subMenu = this.buildMenu(submenuName, eventsStructure, this.getWithoutPrefix(submenuName, menuStructure), submenuName, menuStructure, menuValidFields, i, j);
        menu.addChild(subMenu);
      }
      menu.setActionHelper(this.menuHelper);
      if (menuSpDisplay != null) {
        displayHelper = new S.MenuDisplayHelper(this.events, menuSpDisplay, menu, i, j, p.x, p.y);
        menu.setDisplayHelper(displayHelper);
        displayHelper.start();
      }
      menu.setObj(obj);
      menu.setRoot(menu);
      return menu;
    };

    UI.prototype.buildMenu = function(name, eventsStructure, menuStructure, fullname, fullStructure, validFields, i, j) {
      var desc, displayHelper, index, m, p, price, stName, subMenu, submenuName, submenuNames, title, _i, _len;
      p = this.getPoint(i, j);
      stName = name[0].toUpperCase() + name.slice(1);
      title = eventsStructure[stName].title;
      desc = eventsStructure[stName].desc;
      price = eventsStructure[stName].cost;
      console.log(name, stName, price, fullname, eventsStructure);
      if (title == null) {
        title = "";
      }
      if (desc == null) {
        desc = "";
      }
      eventsStructure = eventsStructure[stName];
      submenuNames = this.getPrefixes(menuStructure);
      if (desc.length > 0 || !submenuNames.length) {
        m = new S.RadialMenu(this.events, this.stage.canvas, 0, 0, title, desc);
        m.setEvent(fullname);
        if (price != null) {
          displayHelper = new S.MenuDisplayHelper(this.events, 'price', m, i, j, p.x, p.y);
          displayHelper.setData(price);
          m.setDisplayHelper(displayHelper);
          displayHelper.start();
        }
        index = _.indexOf(fullStructure, fullname);
        m.setValidFields(validFields[index]);
        return m;
      } else {
        m = new S.RadialMenu(this.events, this.stage.canvas, 0, 0, title, desc);
        for (_i = 0, _len = submenuNames.length; _i < _len; _i++) {
          submenuName = submenuNames[_i];
          subMenu = this.buildMenu(submenuName, eventsStructure, this.getWithoutPrefix(submenuName, menuStructure), fullname + ':' + submenuName, fullStructure, validFields, i, j);
          m.addChild(subMenu);
        }
        return m;
      }
    };

    UI.prototype.getPrefixes = function(list) {
      var prefixes;
      return prefixes = _.chain(list).map(function(el) {
        return el.split(':')[0];
      }).uniq().filter(function(el) {
        return el.length > 0;
      }).value();
    };

    UI.prototype.getWithoutPrefix = function(prefix, list) {
      var listWithout;
      return listWithout = _.chain(list).filter(function(el) {
        return el.split(':')[0] === prefix;
      }).map(function(el) {
        var els;
        return els = (el.split(':').slice(1)).join(':');
      }).filter(function(el) {
        return el.length > 0;
      }).value();
    };

    UI.prototype.getXY = function(ev) {
      var canvasX, canvasY, currentElement, totalOffsetX, totalOffsetY;
      totalOffsetX = 0;
      totalOffsetY = 0;
      canvasX = 0;
      canvasY = 0;
      currentElement = this.stage.canvas;
      totalOffsetX += currentElement.offsetLeft;
      totalOffsetY += currentElement.offsetTop;
      while (currentElement = currentElement.offsetParent) {
        totalOffsetX += currentElement.offsetLeft;
        totalOffsetY += currentElement.offsetTop;
      }
      canvasX = ev.pageX - totalOffsetX;
      canvasY = ev.pageY - totalOffsetY;
      return [canvasX, canvasY];
    };

    UI.prototype.handleClick = function(event) {
      var p, x, y, _ref;
      if (this.events.started) {
        _ref = this.getXY(event), x = _ref[0], y = _ref[1];
        if (event.button !== 2) {
          return;
        }
        p = this.getCoords(new Point(x, y));
        if ((this.curMenu != null) && this.curMenu.hitTest(x, y, true)) {
          if (this.curMenu.positionI === p.x && this.curMenu.positionJ === p.y) {
            this.curMenu.hide(this.curMenu.destroy);
            this.curMenu = null;
          }
          return;
        } else {
          this.handleClickOnField(p.x, p.y);
        }
      }
      return event.preventDefault();
    };

    UI.prototype.handleClickOnField = function(i, j) {
      if (this.events.started) {
        if (this.curMenu != null) {
          this.destroyMenu(this.curMenu);
        }
        this.curMenu = this.createMenu(i, j);
        if (this.curMenu != null) {
          this.curMenu.positionI = i;
          this.curMenu.positionJ = j;
          this.curMenu.show();
          return this.curMenu.click();
        }
      }
    };

    UI.prototype.destroyMenu = function(menu) {
      if (menu != null) {
        return menu.destroy();
      }
    };

    UI.prototype.render = function(i, j) {
      var menu;
      menu = this.createMenu(i, j);
      menu.drawIt();
      menu.show();
      return console.log("Rendering finished");
    };

    return UI;

  })(S.Drawer);

  window.S.UIClass = UI;

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var Terrain,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Terrain = (function(_super) {

    __extends(Terrain, _super);

    function Terrain(events, id, minRow, maxRow, map, useAWorker) {
      this.events = events;
      this.minRow = minRow;
      this.maxRow = maxRow;
      this.moveWater = __bind(this.moveWater, this);

      this.applyBlendMask = __bind(this.applyBlendMask, this);

      this.createBitmapCanvas = __bind(this.createBitmapCanvas, this);

      this.isReady = __bind(this.isReady, this);

      this.canvas = document.getElementById(id);
      this.stage = new Stage(this.canvas);
      this.canvas2 = document.getElementById('water');
      this.waterStage = new Stage(this.canvas2);
      if (useAWorker) {
        this.worker = new Worker('/js/TerrainWorker.js');
        this.worker.postMessage();
        this.worker.addEventListener('message', function(e) {
          var data;
          return data = e.data;
        }, false);
      }
      this.n = 1;
      this.bitmaps = {};
      this.loading = new $.Deferred();
      this.heightMap = this.events.game.map.heightMap;
      this.shadowMap = [];
      this.blendMasks = {};
      this.readyDefer = new $.Deferred();
      this.typesOfTerrain = ['Dirt', 'Grass', 'Water', 'Deepwater', 'Sand', 'Rocks', 'Forest', 'Snow'];
      this.Config = {
        colours: {
          Dirt: [24, 32, 30],
          Sand: [35, 40, 69],
          Water: [180, 51, 38],
          Deepwater: [193, 94, 28],
          Rocks: [60, 1, 49],
          Grass: [57, 42, 44],
          Forest: [84, 27, 25],
          Snow: [180, 16, 96]
        },
        modifiers: {
          h: 1,
          s: 10,
          l: 2
        }
      };
      Terrain.__super__.constructor.call(this, this.minRow, this.maxRow);
      this.heightScale = Math.round(this.canvasDimensions.x / this.events.game.map.heightMapSize);
      this.bitmapWidth = this.distance;
      this.bitmapHeight = this.size * 2;
      this.previousHitTest = [0, 0];
      this.hitHexMap = new Shape();
      this.hitHexMap.graphics.beginFill("#FFF").drawPolyStar(0, 0, this.size, 6, 0, 90);
      this.hitHexMap.visible = false;
      this.hitBitmap = null;
      this.stage.x = -this.horIncrement;
      this.stage.y = -this.size;
      this.stage.addChild(this.hitHexMap);
      this.stage.update();
    }

    Terrain.prototype.isReady = function() {
      return this.readyDefer.promise();
    };

    Terrain.prototype.createBitmapCanvas = function(width, height) {
      var can;
      if (width == null) {
        width = this.bitmapWidth;
      }
      if (height == null) {
        height = this.bitmapHeight;
      }
      can = $("<canvas width=" + width + " height=" + height + " />").appendTo('body').hide();
      return can[0];
    };

    Terrain.prototype.setupBoard = function(boardState) {
      var i, i2, j, j2, k, _i, _ref, _results;
      _results = [];
      for (j = _i = 0, _ref = 2 * this.diffRows + 1; 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (i = _j = 0, _ref1 = this.maxRow - Math.abs(this.diffRows - j); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            _results1.push((function() {
              var _k, _ref2, _ref3, _results2;
              _results2 = [];
              for (k = _k = 0; _k <= 2; k = ++_k) {
                if (((_ref2 = boardState.getChannel(i, j, k)) != null ? _ref2.state : void 0) != null) {
                  _ref3 = this.events.game.map.directionModificators(i, j, k), i2 = _ref3[0], j2 = _ref3[1];
                  _results2.push(this.generateRoad(i, j, i2, j2));
                } else {
                  _results2.push(void 0);
                }
              }
              return _results2;
            }).call(this));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Terrain.prototype.randomTerrain = function() {
      var index;
      index = Math.floor((Math.random() * 100) % this.typesOfTerrain.length);
      return this.typesOfTerrain[index];
    };

    Terrain.prototype.getFieldBitmap = function(type, n) {
      if (n == null) {
        n = 1;
      }
      if (!(this.bitmaps[type] != null) || this.n !== n) {
        this.generateFieldBitmap(type, n);
      }
      return this.bitmaps[type];
    };

    Terrain.prototype.applyBlendMasks = function() {
      var cheight, context, cwidth, i, i2, j, j2, k, km, mask, maskObj, p, t1, t2, t3, terrain, terrainData, terrains, _i, _ref, _results;
      cwidth = this.canvasDimensions.x;
      cheight = this.canvasDimensions.y;
      context = this.stage.canvas.getContext('2d');
      terrainData = context.getImageData(0, 0, cwidth, cheight);
      this.generateBlendMasks();
      _results = [];
      for (j = _i = 0, _ref = 2 * this.diffRows + 1; 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _k, _ref1, _ref2, _results1;
          _results1 = [];
          for (i = _j = 0, _ref1 = this.maxRow - Math.abs(this.diffRows - j); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            terrain = this.getTerrain(i, j);
            terrains = [];
            for (k = _k = 0; _k < 6; k = ++_k) {
              _ref2 = this.events.game.map.directionModificators(i, j, k), i2 = _ref2[0], j2 = _ref2[1];
              terrains[k] = null;
              if (this.events.getField(i2, j2)) {
                terrains[k] = this.getTerrain(i2, j2);
              }
            }
            _results1.push((function() {
              var _l, _results2;
              _results2 = [];
              for (k = _l = 0; _l < 6; k = ++_l) {
                mask = '';
                km = k + 6;
                t1 = terrains[(km - 1) % 6];
                t2 = terrains[km % 6];
                t3 = terrains[(km + 1) % 6];
                if ((t1 != null) && t1 !== terrain) {
                  mask += 'l';
                }
                if ((t2 != null) && t2 !== terrain) {
                  mask += 'f';
                }
                if ((t3 != null) && t3 !== terrain) {
                  mask += 'r';
                }
                if (mask.length > 0 && mask !== 'lr' && mask !== 'l' && mask !== 'r') {
                  p = this.getPoint(i, j);
                  maskObj = this.blendMasks[mask].clone();
                  console.log("[Terrain] apply a mask");
                  _results2.push(this.applyBlendMask(maskObj, t2, p.x, p.y, k));
                } else {
                  _results2.push(void 0);
                }
              }
              return _results2;
            }).call(this));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Terrain.prototype.applyBlendMask = function(mask, terrain, x, y, k, width, height) {
      var a, a1, a2, b, b1, b2, b3, blendCanvas, blendContext, blendData, blendStage, blendTerrain, cheight, context, cwidth, g, g1, g2, g3, maskCanvas, maskContext, maskData, maskStage, newTerrain, r, r1, r2, r3, terrainData, w, xp, yp, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      if (width == null) {
        width = this.size;
      }
      if (height == null) {
        height = this.size;
      }
      cwidth = this.canvasDimensions.x;
      cheight = this.canvasDimensions.y;
      mask.regX = Math.round(width / 2);
      mask.regY = Math.round(this.size - this.horIncrement);
      mask.rotation = Math.PI / 2 + Math.PI / 3 * k;
      mask.x = x;
      mask.y = y;
      maskCanvas = this.createBitmapCanvas(cwidth, cheight);
      maskContext = maskCanvas.getContext('2d');
      maskStage = new Stage(maskCanvas);
      maskStage.addChild(mask);
      maskStage.update();
      maskData = maskContext.getImageData(0, 0, cwidth, cheight);
      $(maskCanvas).remove();
      blendTerrain = this.getFieldBitmap(terrain);
      blendCanvas = this.createBitmapCanvas(cwidth, cheight);
      blendContext = blendCanvas.getContext('2d');
      blendStage = new Stage(blendCanvas);
      blendStage.addChild(blendTerrain);
      blendTerrain.x = x;
      blendTerrain.y = y;
      blendStage.update();
      blendData = blendContext.getImageData(0, 0, cwidth, cheight);
      $(blendCanvas).remove();
      context = this.stage.canvas.getContext('2d');
      terrainData = context.getImageData(0, 0, cwidth, cheight);
      for (xp = _i = _ref = x - this.size, _ref1 = x + this.size; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; xp = _ref <= _ref1 ? ++_i : --_i) {
        for (yp = _j = _ref2 = y - this.size, _ref3 = y + this.size; _ref2 <= _ref3 ? _j < _ref3 : _j > _ref3; yp = _ref2 <= _ref3 ? ++_j : --_j) {
          _ref4 = this.getPixel(maskData, xp, yp), r = _ref4[0], g = _ref4[1], b = _ref4[2], a = _ref4[3];
          if (a > 0) {
            _ref5 = this.getPixel(blendData, xp, yp), r1 = _ref5[0], g1 = _ref5[1], b1 = _ref5[2], a1 = _ref5[3];
            _ref6 = this.getPixel(terrainData, xp, yp), r2 = _ref6[0], g2 = _ref6[1], b2 = _ref6[2], a2 = _ref6[3];
            w = a / 255;
            r3 = Math.round(r2 * w + r1 * (1 - w));
            g3 = Math.round(g2 * w + g1 * (1 - w));
            b3 = Math.round(b2 * w + b1 * (1 - w));
            this.setPixel(terrainData, xp, yp, [r3, g3, b3, a2]);
          }
        }
      }
      newTerrain = this.createBitmapObjFromBitmap(terrainData, cwidth, cheight);
      this.stage.removeAllChildren();
      this.stage.addChild(newTerrain);
      return this.stage.update();
    };

    Terrain.prototype.generateBlendMasks = function() {
      var cp, drawBlendMask, generateBlendMask, h, lbp, llp, midHeightLX, midHeightRX, midHeightY, range, rbp, rrp, steps,
        _this = this;
      steps = 8;
      h = 0.6;
      range = 8;
      drawBlendMask = function(bitmap, points, n) {
        var alpha, cY, gradientY, i, x, x1, x2, xp, xp2, y, y1, y2, yp, yp2, _i, _j, _k, _l, _m, _n, _o, _p, _q, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        for (x = _i = 0, _ref = _this.size; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
          for (y = _j = 0, _ref1 = _this.size; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
            _this.setPixel(bitmap, x, y, [0, 0, 0, 255]);
          }
        }
        if (n === 1 || n === 2) {
          x1 = 0;
          y1 = _this.size - 1;
          x2 = Math.round(_this.size / 4);
          y2 = _this.size - Math.round(Math.sqrt(3) * _this.size / 4);
          gradientY = (y2 - y1) / (x2 - x1);
          for (x = _k = x1; x1 <= x2 ? _k <= x2 : _k >= x2; x = x1 <= x2 ? ++_k : --_k) {
            cY = y1;
            for (y = _l = 0; 0 <= cY ? _l < cY : _l > cY; y = 0 <= cY ? ++_l : --_l) {
              _this.setPixel(bitmap, x, y, [0, 0, 0, 0]);
            }
            cY = Math.round(cY + gradientY);
          }
        }
        if (n === 3 || n === 2) {
          x2 = _this.size - 1;
          y2 = _this.size - 1;
          x1 = Math.round(3 * _this.size / 4);
          y1 = _this.size - Math.round(Math.sqrt(3) * _this.size / 4);
          gradientY = (y2 - y1) / (x2 - x1);
          for (x = _m = x1; x1 <= x2 ? _m <= x2 : _m >= x2; x = x1 <= x2 ? ++_m : --_m) {
            cY = y1;
            for (y = _n = 0; 0 <= cY ? _n < cY : _n > cY; y = 0 <= cY ? ++_n : --_n) {
              _this.setPixel(bitmap, x, y, [0, 0, 0, 0]);
            }
            cY = Math.round(cY + gradientY);
          }
        }
        for (i = _o = 0, _ref2 = points.length - 1; 0 <= _ref2 ? _o < _ref2 : _o > _ref2; i = 0 <= _ref2 ? ++_o : --_o) {
          _ref3 = points[i], xp = _ref3[0], yp = _ref3[1];
          _ref4 = points[i + 1], xp2 = _ref4[0], yp2 = _ref4[1];
          gradientY = (yp2 - yp) / (xp2 - xp);
          for (x = _p = xp; xp <= xp2 ? _p < xp2 : _p > xp2; x = xp <= xp2 ? ++_p : --_p) {
            cY = yp;
            alpha = 0;
            for (y = _q = _ref5 = _this.size - 1; _ref5 <= cY ? _q < cY : _q > cY; y = _ref5 <= cY ? ++_q : --_q) {
              alpha = alpha + ((cY - _this.size + 1) * (cY - _this.size + 1)) + Math.round(Math.random() * 10);
              _this.setPixel(bitmap, x, y, [0, 0, 0, alpha]);
            }
            cY = Math.round(cY + gradientY);
          }
        }
        return null;
      };
      generateBlendMask = function(p1, p2, n, p3) {
        var bitmap, points;
        if (p3 != null) {
          points = p1.concat(p2, p3);
        } else {
          points = p1.concat(p2);
        }
        points = _this.midpointMisplacement(steps, h, range, points);
        bitmap = _this.context.createImageData(_this.size, _this.size);
        drawBlendMask(bitmap, points, n);
        return _this.createBitmapObjFromBitmap(bitmap, _this.size, _this.size);
      };
      midHeightLX = Math.round(this.size / 4);
      midHeightY = this.size - Math.round(Math.sqrt(3) * this.size / 4);
      midHeightRX = Math.round(this.size * 3 / 4);
      lbp = [0, this.size - 1];
      llp = [midHeightLX, midHeightY];
      rbp = [this.size - 1, this.size - 1];
      rrp = [midHeightRX, midHeightY];
      cp = [Math.round(this.size / 2), 0];
      this.blendMasks.f = generateBlendMask(lbp, cp, rbp, 0);
      this.blendMasks.lf = generateBlendMask(llp, rbp, 1);
      this.blendMasks.fr = generateBlendMask(lbp, rrp, 2);
      return this.blendMasks.lfr = generateBlendMask(llp, rrp, 3);
    };

    Terrain.prototype.createBitmapObjFromBitmap = function(bitmap, width, height) {
      var bitmapCanvas, bitmapObj, context;
      bitmapCanvas = this.createBitmapCanvas(width, height);
      context = bitmapCanvas.getContext('2d');
      bitmapCanvas.getContext('2d').putImageData(bitmap, 0, 0);
      bitmapObj = new Bitmap(bitmapCanvas);
      $(bitmapCanvas).remove();
      return bitmapObj;
    };

    Terrain.prototype.generateRoad = function(i, j, i2, j2) {
      var bitmap, bitmapObj, cHeight, cWidth, p;
      cWidth = this.canvasDimensions.x;
      cHeight = this.canvasDimensions.y;
      bitmap = this.context.createImageData(cWidth, cHeight);
      this.drawRoad(bitmap, i, j, i2, j2);
      bitmapObj = this.createBitmapObjFromBitmap(bitmap, cWidth, cHeight);
      p = this.getPoint(i, j);
      this.stage.addChild(bitmapObj);
      return this.stage.update();
    };

    Terrain.prototype.billinearInterpolation = function(x, y) {
      var fp, q11, q12, q21, q22, tile, x1, x2, y1, y2, z;
      z = 0;
      x1 = Math.floor(x / this.heightScale);
      y1 = Math.floor(y / this.heightScale);
      tile = this.heightMap.tile(x1, y1);
      q11 = this.heightMap.get_cell(x1, y1);
      q21 = this.heightMap.get_cell(x1 + 1, y1);
      q12 = this.heightMap.get_cell(x1, y1 + 1);
      q22 = this.heightMap.get_cell(x1 + 1, y1 + 1);
      x2 = x1 + 1;
      y2 = y1 + 1;
      x1 = Math.floor(x1 * this.heightScale);
      y1 = Math.floor(y1 * this.heightScale);
      x2 = Math.floor(x2 * this.heightScale);
      y2 = Math.floor(y2 * this.heightScale);
      fp = (q11 / ((x2 - x1) * (y2 - y1))) * (x2 - x) * (y2 - y) + (q21 / ((x2 - x1) * (y2 - y1))) * (x - x1) * (y2 - y) + (q12 / ((x2 - x1) * (y2 - y1))) * (x2 - x) * (y - y1) + (q22 / ((x2 - x1) * (y2 - y1))) * (x - x1) * (y - y1);
      z = fp;
      return z;
    };

    Terrain.prototype.midpointMisplacement = function(steps, h, range, points) {
      var i, j, misplace, misplaced, newCoords, oldCoords, _i, _j, _ref;
      oldCoords = points.slice(0);
      misplace = function(_arg, _arg1) {
        var m, x1, x2, y1, y2;
        x1 = _arg[0], y1 = _arg[1];
        x2 = _arg1[0], y2 = _arg1[1];
        m = Math.round(Math.random() * range - range / 2);
        return [Math.round((x1 + x2) / 2), Math.round((y1 + y2) / 2) + m];
      };
      for (i = _i = 0; 0 <= steps ? _i < steps : _i > steps; i = 0 <= steps ? ++_i : --_i) {
        newCoords = [];
        for (j = _j = 0, _ref = oldCoords.length - 1; 0 <= _ref ? _j < _ref : _j > _ref; j = 0 <= _ref ? ++_j : --_j) {
          misplaced = misplace(oldCoords[j], oldCoords[j + 1]);
          newCoords.push(oldCoords[j]);
          newCoords.push(misplaced.slice(0));
        }
        newCoords.push(oldCoords[oldCoords.length - 1]);
        oldCoords = newCoords.slice(0);
        range = range / Math.pow(2, h);
      }
      return oldCoords;
    };

    Terrain.prototype.drawRoad = function(roadImage, i, j, i2, j2) {
      var colourr, colourt, cr, ct, drawByX, gradientX, gradientY, h, ht, l, lt, oldCoords, p, p1, p2, range, rgbcr, rgbct, s, st, steps, _i, _ref, _ref1, _ref2, _results;
      steps = 16;
      h = 1;
      range = 20;
      _ref = this.Config.colours[this.getTerrain(i, j)], ht = _ref[0], st = _ref[1], lt = _ref[2];
      colourt = "hsl(" + ht + "," + st + "%," + lt + "%)";
      _ref1 = this.Config.colours.Dirt, h = _ref1[0], s = _ref1[1], l = _ref1[2];
      colourr = "hsl(" + h + "," + s + "%," + l + "%)";
      cr = net.brehaut.Color(colourr);
      ct = net.brehaut.Color(colourt);
      rgbcr = [Math.round(cr.getRed() * 255), Math.round(cr.getGreen() * 255), Math.round(cr.getBlue() * 255)];
      rgbct = [Math.round(ct.getRed() * 255), Math.round(ct.getGreen() * 255), Math.round(ct.getBlue() * 255)];
      p1 = this.getPoint(i, j);
      p2 = this.getPoint(i2, j2);
      if (p1.x > p2.x) {
        p = p1;
        p1 = p2;
        p2 = p;
      }
      oldCoords = [[p1.x, p1.y], [p2.x, p2.y]];
      gradientY = (p2.y - p1.y) / (p2.x - p1.x);
      gradientX = (p2.x - p1.x) / (p2.y - p1.y);
      oldCoords = this.midpointMisplacement(steps, h, range, oldCoords);
      drawByX = gradientX > gradientY;
      console.log(gradientY, gradientX, drawByX);
      _results = [];
      for (i = _i = 0, _ref2 = oldCoords.length - 1; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        _results.push(this.drawRoadSegment(roadImage, rgbcr, rgbct, oldCoords[i], oldCoords[i + 1], drawByX));
      }
      return _results;
    };

    Terrain.prototype.drawCircle = function(image, x, y, radius, _arg, _arg1) {
      var alpha, b, b1, b2, g, g1, g2, i, j, mr, r, r1, r2, sqR, _i, _results;
      r1 = _arg[0], g1 = _arg[1], b1 = _arg[2];
      r2 = _arg1[0], g2 = _arg1[1], b2 = _arg1[2];
      sqR = radius * radius;
      mr = -1 * radius;
      _results = [];
      for (i = _i = mr; mr <= radius ? _i < radius : _i > radius; i = mr <= radius ? ++_i : --_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (j = _j = mr; mr <= radius ? _j < radius : _j > radius; j = mr <= radius ? ++_j : --_j) {
            if (sqI + sqJ <= sqR) {
              alpha = 0.3;
              r = Math.round(r1 * (1 - alpha) + r2 * alpha);
              g = Math.round(g1 * (1 - alpha) + g2 * alpha);
              b = Math.round(b1 * (1 - alpha) + b2 * alpha);
              _results1.push(this.setPixel(image, i + x, j + y, [r, g, b, Math.round((1 - alpha) * 255)]));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Terrain.prototype.drawRoadSegment = function(roadImage, _arg, _arg1, _arg2, _arg3, drawItByX) {
      var b1, b2, cX, cY, drawByX, drawByY, g1, g2, gradientX, gradientY, r1, r2, width, x1, x2, y1, y2,
        _this = this;
      r1 = _arg[0], g1 = _arg[1], b1 = _arg[2];
      r2 = _arg1[0], g2 = _arg1[1], b2 = _arg1[2];
      x1 = _arg2[0], y1 = _arg2[1];
      x2 = _arg3[0], y2 = _arg3[1];
      width = 15;
      cY = Math.round(y1 - width / 2);
      cX = Math.round(x1 - width / 2);
      gradientY = (y2 - y1) / (x2 - x1);
      gradientX = (x2 - x1) / (y2 - y1);
      x1 = Math.round(x1 - width / 2);
      x2 = Math.round(x2 - width / 2);
      y1 = Math.round(y1 - width / 2);
      y2 = Math.round(y2 - width / 2);
      drawByX = function() {
        var alpha, b, g, i, offY, r, _i, _j, _results;
        _results = [];
        for (cX = _i = x1; x1 <= x2 ? _i <= x2 : _i >= x2; cX = x1 <= x2 ? ++_i : --_i) {
          offY = Math.round(width / 2);
          for (i = _j = 0; 0 <= width ? _j < width : _j > width; i = 0 <= width ? ++_j : --_j) {
            alpha = (Math.pow(Math.round(Math.abs(i - offY) / width), 2) * 2 + Math.random()) / 4;
            r = Math.round(r1 * (1 - alpha) + r2 * alpha);
            g = Math.round(g1 * (1 - alpha) + g2 * alpha);
            b = Math.round(b1 * (1 - alpha) + b2 * alpha);
            _this.setPixel(roadImage, cX, cY + i, [r, g, b, Math.round((1 - alpha) * 255)]);
          }
          _results.push(cY += gradientY);
        }
        return _results;
      };
      drawByY = function() {
        var alpha, b, g, i, offX, r, _i, _j, _results;
        _results = [];
        for (cY = _i = y1; y1 <= y2 ? _i <= y2 : _i >= y2; cY = y1 <= y2 ? ++_i : --_i) {
          offX = Math.round(width / 2);
          for (i = _j = 0; 0 <= width ? _j < width : _j > width; i = 0 <= width ? ++_j : --_j) {
            alpha = (Math.pow(Math.round(Math.abs(i - offX) / width), 2) * 2 + Math.random()) / 4;
            r = Math.round(r1 * (1 - alpha) + r2 * alpha);
            g = Math.round(g1 * (1 - alpha) + g2 * alpha);
            b = Math.round(b1 * (1 - alpha) + b2 * alpha);
            _this.setPixel(roadImage, cX + i, cY, [r, g, b, Math.round((1 - alpha) * 255)]);
          }
          _results.push(cX += gradientX);
        }
        return _results;
      };
      if (drawItByX) {
        drawByX();
      } else {
        drawByY();
      }
      return null;
    };

    Terrain.prototype.getK = function(i, j, ci, cj) {
      var h, ks, mi, mj, r;
      mi = ci - i;
      mj = cj - j;
      ks = [[-1, -1], [0, -1], [1, 0], [1, 1], [0, 1], [-1, 0]];
      h = _.map(ks, function(_arg, i) {
        var mik, mjk;
        mik = _arg[0], mjk = _arg[1];
        if (mik === mi && mjk === mj) {
          return i;
        } else {
          return 7;
        }
      });
      r = _.find(h, function(v, i) {
        return v !== 7;
      });
      return r;
    };

    Terrain.prototype.getIJ = function(i, j, k) {
      var mi, mj;
      mi = [-1, 0, 1, 1, 0, -1];
      mj = [-1, -1, 0, 1, 1, 0];
      return [i + mi[k], j + mj[k]];
    };

    Terrain.prototype.getWaterBitmap = function() {
      var bitmap, i, j, oldL, _i, _j, _ref, _ref1;
      if (!(this.waterBitmap != null)) {
        bitmap = this.context.createImageData(this.bitmapWidth, this.bitmapHeight);
        oldL = this.Config.modifiers.s;
        this.Config.modifiers.s = 12;
        for (i = _i = 0, _ref = this.bitmapWidth; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          for (j = _j = 0, _ref1 = this.bitmapHeight; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            this.drawPoint(bitmap, i, j, this.Config.colours.Deepwater, 1);
          }
        }
        this.Config.modifiers.s = oldL;
        this.waterBitmap = this.createBitmapObjFromBitmap(bitmap, this.bitmapWidth, this.bitmapHeight);
      }
      return this.waterBitmap.clone();
    };

    Terrain.prototype.generateFieldBitmap = function(type, n) {
      var bitmap, bitmapCanvas, context;
      if (n == null) {
        n = 1;
      }
      bitmap = this.context.createImageData(this.bitmapWidth, this.bitmapHeight);
      this.drawField(bitmap, 0, 0, type, n);
      if (!(this.hitBitmap != null)) {
        this.hitBitmap = bitmap;
      }
      bitmapCanvas = this.createBitmapCanvas();
      context = bitmapCanvas.getContext('2d');
      context.clearRect(0, 0, this.bitmapWidth, this.bitmapHeight);
      bitmapCanvas.getContext('2d').putImageData(bitmap, 0, 0);
      this.bitmaps[type] = new Bitmap(bitmapCanvas);
      $(bitmapCanvas).remove();
      return bitmap;
    };

    Terrain.prototype.generateShadowMap = function(terrainBitmap) {
      var a, b, context, g, heightDiff, heightMap, r, shadowHeight, shadowMap, sourceHeight, sunVisibilityHeight, terrainData, x, y, _i, _j, _k, _l, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      shadowMap = [];
      heightMap = [];
      sunVisibilityHeight = 2;
      for (x = _i = 0, _ref = this.canvasDimensions.x; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        shadowMap[x] = [];
        for (y = _j = 0, _ref1 = this.canvasDimensions.y; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          shadowMap[x][y] = [0];
        }
      }
      console.log("[Terrain] shadow map initialized");
      context = this.stage.canvas.getContext('2d');
      terrainData = context.getImageData(0, 0, this.canvasDimensions.x, this.canvasDimensions.y);
      for (x = _k = 0, _ref2 = this.canvasDimensions.x; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; x = 0 <= _ref2 ? ++_k : --_k) {
        heightMap[x] = [];
        for (y = _l = 0, _ref3 = this.canvasDimensions.y; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; y = 0 <= _ref3 ? ++_l : --_l) {
          _ref4 = this.getPixel(terrainData, x, y), r = _ref4[0], g = _ref4[1], b = _ref4[2], a = _ref4[3];
          if (a > 0) {
            heightMap[x][y] = this.getHeight(x, y) + 10;
          }
        }
      }
      console.log("[Terrain] height map generated");
      for (x = _m = 1, _ref5 = this.canvasDimensions.x; 1 <= _ref5 ? _m < _ref5 : _m > _ref5; x = 1 <= _ref5 ? ++_m : --_m) {
        for (y = _n = _ref6 = this.canvasDimensions.y - 2; _ref6 <= 0 ? _n <= 0 : _n >= 0; y = _ref6 <= 0 ? ++_n : --_n) {
          sourceHeight = heightMap[x][y];
          shadowHeight = heightMap[x - 1][y + 1];
          heightDiff = sourceHeight - shadowHeight;
          heightDiff /= sunVisibilityHeight;
          if (heightDiff * shadowMap[x - 1][y + 1] > 0) {
            shadowMap[x][y] = heightDiff + shadowMap[x - 1][y + 1] / (sunVisibilityHeight * 2);
          } else {
            shadowMap[x][y] = heightDiff;
          }
        }
      }
      console.log("[Terrain] shadow map generated");
      return shadowMap;
    };

    Terrain.prototype.getHeight = function(x, y) {
      return this.billinearInterpolation(x, y);
    };

    Terrain.prototype.project = function(x, y, z) {
      var x2, y2;
      x2 = Math.round(x + z / 4);
      y2 = Math.round(y + z / 2);
      return [x2, y2];
    };

    Terrain.prototype.getShadowStrength = function(height) {
      return height;
    };

    Terrain.prototype.generateSurroundingWater = function() {
      var b, i, j, m, n, _i, _j;
      n = Math.floor(this.canvasDimensions.y / this.bitmapHeight);
      m = Math.floor(this.canvasDimensions.x / this.bitmapWidth);
      for (i = _i = 0; 0 <= n ? _i <= n : _i >= n; i = 0 <= n ? ++_i : --_i) {
        for (j = _j = 0; 0 <= m ? _j <= m : _j >= m; j = 0 <= m ? ++_j : --_j) {
          b = this.getWaterBitmap();
          b.y = i * this.bitmapHeight;
          b.x = j * this.bitmapWidth;
          this.waterStage.addChildAt(b, 0);
        }
      }
      return this.waterStage.update();
    };

    Terrain.prototype.moveWater = function() {
      var cheight, cwidth, damping, x, y, _i, _j;
      damping = 0.6;
      cwidth = this.canvasDimensions.x;
      cheight = this.canvasDimensions.y;
      for (x = _i = 0; 0 <= cwidth ? _i < cwidth : _i > cwidth; x = 0 <= cwidth ? ++_i : --_i) {
        for (y = _j = 0; 0 <= cheight ? _j < cheight : _j > cheight; y = 0 <= cheight ? ++_j : --_j) {
          if (x !== 0 && y !== 0 && x !== cwidth - 1 && y !== cheight - 1) {
            this.waterBuffer2[x][y] = (this.waterBuffer1[x - 1][y] + this.waterBuffer1[x + 1][y] + this.waterBuffer1[x][y + 1] + this.waterBuffer1[x][y - 1]) / 2 - this.waterBuffer2[x][y];
            this.waterBuffer2[x][y] = this.waterBuffer2[x][y] * damping;
          } else {
            this.waterBuffer2[x][y] = 50;
            this.waterBuffer2[x][y] = 50;
          }
        }
      }
      this.displayWaterBuffer(this.waterBuffer2);
      this.buffer = this.waterBuffer1;
      this.waterBuffer1 = this.waterBuffer2;
      this.waterBuffer2 = this.buffer;
      return null;
    };

    Terrain.prototype.initializeWaterBuffer = function() {
      var cheight, cwidth, x, y, _i, _j;
      this.waterBuffer1 = [];
      this.waterBuffer2 = [];
      cwidth = this.canvasDimensions.x;
      cheight = this.canvasDimensions.y;
      for (x = _i = 0; 0 <= cwidth ? _i < cwidth : _i > cwidth; x = 0 <= cwidth ? ++_i : --_i) {
        this.waterBuffer1[x] = [];
        this.waterBuffer2[x] = [];
        for (y = _j = 0; 0 <= cheight ? _j < cheight : _j > cheight; y = 0 <= cheight ? ++_j : --_j) {
          if (x % 16 === 0) {
            this.waterBuffer1[x][y] = 50;
            this.waterBuffer1[x][y] = 50;
            this.waterBuffer2[x][y] = 50;
            this.waterBuffer2[x][y] = 50;
          } else {
            this.waterBuffer1[x][y] = 0;
            this.waterBuffer1[x][y] = 0;
            this.waterBuffer2[x][y] = 0;
            this.waterBuffer2[x][y] = 0;
          }
        }
      }
      return null;
    };

    Terrain.prototype.displayWaterBuffer = function(buffer) {
      var b, bm, c, cheight, colour, context, cwidth, g, gm, h, l, r, rm, s, water, waterData, x, y, _i, _j, _ref;
      cwidth = this.canvasDimensions.x;
      cheight = this.canvasDimensions.y;
      context = this.waterStage.canvas.getContext('2d');
      waterData = context.getImageData(0, 0, cwidth, cheight);
      _ref = this.Config.colours.deepwater, h = _ref[0], s = _ref[1], l = _ref[2];
      colour = "hsl(" + h + "," + s + "%," + l + "%)";
      c = net.brehaut.Color(colour);
      r = Math.floor(c.getRed() * 255);
      g = Math.floor(c.getGreen() * 255);
      b = Math.floor(c.getBlue() * 255);
      for (x = _i = 0; 0 <= cwidth ? _i < cwidth : _i > cwidth; x = 0 <= cwidth ? ++_i : --_i) {
        for (y = _j = 0; 0 <= cheight ? _j < cheight : _j > cheight; y = 0 <= cheight ? ++_j : --_j) {
          h = buffer[x][y];
          rm = r - h * r + 10;
          gm = g - h * r + 10;
          bm = b - h * r + 10;
          this.setPixel(waterData, x, y, [rm, gm, bm, 255]);
        }
      }
      water = this.createBitmapObjFromBitmap(waterData, cwidth, cheight);
      this.waterStage.removeAllChildren();
      this.waterStage.addChild(water);
      this.waterStage.update();
      return null;
    };

    Terrain.prototype.applyHeightMap = function() {
      var a, b, context, g, r, shadow, terrain, terrainCanvas, terrainData, x, x2, y, y2, _i, _j, _ref, _ref1, _ref2, _ref3;
      this.shadowMap = this.generateShadowMap();
      context = this.stage.canvas.getContext('2d');
      terrainData = context.getImageData(0, 0, this.canvasDimensions.x, this.canvasDimensions.y);
      for (x = _i = 0, _ref = this.canvasDimensions.x; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = this.canvasDimensions.y; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          _ref2 = this.getPixel(terrainData, x, y), r = _ref2[0], g = _ref2[1], b = _ref2[2], a = _ref2[3];
          if (a === 0) {
            continue;
          }
          _ref3 = [x, y], x2 = _ref3[0], y2 = _ref3[1];
          shadow = this.shadowMap[x][y];
          this.setPixel(terrainData, x2, y2, [Math.round(r - Math.round(r * shadow)), Math.round(g - Math.round(g * shadow)), Math.round(b - Math.round(b * shadow)), a]);
        }
      }
      terrainCanvas = this.createBitmapCanvas(this.canvasDimensions.x, this.canvasDimensions.y);
      context = terrainCanvas.getContext('2d');
      terrainCanvas.getContext('2d').putImageData(terrainData, 0, 0);
      terrain = new Bitmap(terrainCanvas);
      $(terrainCanvas).remove();
      this.stage.removeAllChildren();
      this.stage.addChild(terrain);
      this.stage.x = 0;
      this.stage.y = 0;
      return this.stage.update();
    };

    Terrain.prototype.getPixel = function(imageData, x, y) {
      var d, index;
      index = (x + y * imageData.width) * 4;
      d = imageData.data;
      return [d[index + 0], d[index + 1], d[index + 2], d[index + 3]];
    };

    Terrain.prototype.setPixel = function(imageData, x, y, _arg) {
      var a, b, d, g, index, r;
      r = _arg[0], g = _arg[1], b = _arg[2], a = _arg[3];
      index = (x + y * imageData.width) * 4;
      d = imageData.data;
      d[index + 0] = r;
      d[index + 1] = g;
      d[index + 2] = b;
      return d[index + 3] = a;
    };

    Terrain.prototype.getTerrain = function(i, j) {
      var t;
      t = this.events.getField(i, j).terrain[0];
      return S.Types.Terrain.Names[t - 1];
    };

    Terrain.prototype.draw = function(n) {
      var b, bitmap, i, j, p, _i, _j, _ref, _ref1;
      if (n == null) {
        n = 1;
      }
      this.hitHexMap.visible = true;
      this.context = this.stage.canvas.getContext('2d');
      for (j = _i = 0, _ref = 2 * this.diffRows + 1; 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {
        for (i = _j = 0, _ref1 = this.maxRow - Math.abs(this.diffRows - j); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          bitmap = this.getFieldBitmap(this.getTerrain(i, j), n);
          p = this.getPoint(i, j);
          b = bitmap.clone();
          b.x = p.x;
          b.y = p.y;
          this.stage.addChild(b);
        }
      }
      this.n = n;
      this.loading.notify(100);
      this.stage.update();
      this.hitHexMap.visible = false;
      this.events.game.map.smoothenTheTerrain(32);
      this.loading.notify(100);
      this.applyHeightMap();
      this.loading.notify(150);
      this.generateSurroundingWater();
      this.loading.notify(50);
      this.stage.update();
      this.hideWater();
      this.hideTerrain();
      return this.readyDefer.resolve();
    };

    Terrain.prototype.t = 0;

    Terrain.prototype.showWater = function() {
      return $(this.canvas2).show();
    };

    Terrain.prototype.showTerrain = function() {
      return $(this.canvas).show();
    };

    Terrain.prototype.hideWater = function() {
      return $(this.canvas2).hide();
    };

    Terrain.prototype.hideTerrain = function() {
      return $(this.canvas).hide();
    };

    Terrain.prototype.drawField = function(image, i, j, type, n) {
      var a, b, colour, dpx, dpy, g, p, p0, px, py, r, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4;
      if (n == null) {
        n = 1;
      }
      if (type === 'Water') {
        return;
      }
      colour = this.Config.colours[type];
      p = this.getPoint(i, j);
      p0 = this.getPoint(0, 0);
      for (px = _i = _ref = p.x - this.horIncrement, _ref1 = p.x + this.horIncrement + n; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; px = _i += n) {
        for (py = _j = _ref2 = p.y - this.size, _ref3 = p.y + this.size + n; _ref2 <= _ref3 ? _j < _ref3 : _j > _ref3; py = _j += n) {
          dpx = px - p0.x + this.horIncrement;
          dpy = py - p0.y + this.size;
          if (i === 0 && j === 0 && this.t === 0) {
            this.t = 1;
          }
          if (this.hitBimap != null) {
            _ref4 = this.getPixel(this.hitBimap, px, py), r = _ref4[0], g = _ref4[1], b = _ref4[2], a = _ref4[3];
            if (a > 0) {
              this.drawPoint(image, dpx, dpy, colour, n);
            }
          } else if (this.fieldHitTest(i, j, px, py, n)) {
            this.drawPoint(image, dpx, dpy, colour, n);
          }
        }
      }
      return null;
    };

    Terrain.prototype.fieldHitTest = function(i, j, x, y, n) {
      var p;
      if (n == null) {
        n = 1;
      }
      p = this.getPoint(i, j);
      return this.hitHexMap.hitTest(x - p.x, y - p.y);
    };

    Terrain.prototype.drawPoint = function(image, x, y, initialColour, n) {
      var c, colour, h, hM, i, j, l, lM, s, sM, _i, _j;
      hM = ((Math.random() * 100) % 2 * this.Config.modifiers.h) - this.Config.modifiers.h;
      sM = ((Math.random() * 100) % 2 * this.Config.modifiers.s) - this.Config.modifiers.s;
      lM = ((Math.random() * 100) % 2 * this.Config.modifiers.l) - this.Config.modifiers.l;
      h = initialColour[0], s = initialColour[1], l = initialColour[2];
      h += hM;
      s += sM;
      l += lM;
      colour = "hsl(" + h + "," + s + "%," + l + "%)";
      c = net.brehaut.Color(colour);
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        for (j = _j = 0; 0 <= n ? _j < n : _j > n; j = 0 <= n ? ++_j : --_j) {
          this.setPixel(image, x + i, y + j, [c.getRed() * 255, c.getGreen() * 255, c.getBlue() * 255, 255]);
        }
      }
      return null;
    };

    return Terrain;

  })(S.Drawer);

  window.S.Terrain = Terrain;

}).call(this);
